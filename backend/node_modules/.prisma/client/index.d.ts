
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model LeadNote
 * 
 */
export type LeadNote = $Result.DefaultSelection<Prisma.$LeadNotePayload>
/**
 * Model SkipTraceRecord
 * 
 */
export type SkipTraceRecord = $Result.DefaultSelection<Prisma.$SkipTraceRecordPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignLog
 * 
 */
export type CampaignLog = $Result.DefaultSelection<Prisma.$CampaignLogPayload>
/**
 * Model CallLog
 * 
 */
export type CallLog = $Result.DefaultSelection<Prisma.$CallLogPayload>
/**
 * Model ScrapingJob
 * 
 */
export type ScrapingJob = $Result.DefaultSelection<Prisma.$ScrapingJobPayload>
/**
 * Model PropertyRecord
 * 
 */
export type PropertyRecord = $Result.DefaultSelection<Prisma.$PropertyRecordPayload>
/**
 * Model DailyMetric
 * 
 */
export type DailyMetric = $Result.DefaultSelection<Prisma.$DailyMetricPayload>
/**
 * Model ScraperJob
 * 
 */
export type ScraperJob = $Result.DefaultSelection<Prisma.$ScraperJobPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ScraperSource: {
  zillow: 'zillow',
  auction: 'auction'
};

export type ScraperSource = (typeof ScraperSource)[keyof typeof ScraperSource]


export const JobStatus: {
  queued: 'queued',
  running: 'running',
  completed: 'completed',
  failed: 'failed'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]

}

export type ScraperSource = $Enums.ScraperSource

export const ScraperSource: typeof $Enums.ScraperSource

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.leadNote`: Exposes CRUD operations for the **LeadNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadNotes
    * const leadNotes = await prisma.leadNote.findMany()
    * ```
    */
  get leadNote(): Prisma.LeadNoteDelegate<ExtArgs>;

  /**
   * `prisma.skipTraceRecord`: Exposes CRUD operations for the **SkipTraceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkipTraceRecords
    * const skipTraceRecords = await prisma.skipTraceRecord.findMany()
    * ```
    */
  get skipTraceRecord(): Prisma.SkipTraceRecordDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignLog`: Exposes CRUD operations for the **CampaignLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignLogs
    * const campaignLogs = await prisma.campaignLog.findMany()
    * ```
    */
  get campaignLog(): Prisma.CampaignLogDelegate<ExtArgs>;

  /**
   * `prisma.callLog`: Exposes CRUD operations for the **CallLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallLogs
    * const callLogs = await prisma.callLog.findMany()
    * ```
    */
  get callLog(): Prisma.CallLogDelegate<ExtArgs>;

  /**
   * `prisma.scrapingJob`: Exposes CRUD operations for the **ScrapingJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScrapingJobs
    * const scrapingJobs = await prisma.scrapingJob.findMany()
    * ```
    */
  get scrapingJob(): Prisma.ScrapingJobDelegate<ExtArgs>;

  /**
   * `prisma.propertyRecord`: Exposes CRUD operations for the **PropertyRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyRecords
    * const propertyRecords = await prisma.propertyRecord.findMany()
    * ```
    */
  get propertyRecord(): Prisma.PropertyRecordDelegate<ExtArgs>;

  /**
   * `prisma.dailyMetric`: Exposes CRUD operations for the **DailyMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyMetrics
    * const dailyMetrics = await prisma.dailyMetric.findMany()
    * ```
    */
  get dailyMetric(): Prisma.DailyMetricDelegate<ExtArgs>;

  /**
   * `prisma.scraperJob`: Exposes CRUD operations for the **ScraperJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScraperJobs
    * const scraperJobs = await prisma.scraperJob.findMany()
    * ```
    */
  get scraperJob(): Prisma.ScraperJobDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organization: 'Organization',
    User: 'User',
    Lead: 'Lead',
    LeadNote: 'LeadNote',
    SkipTraceRecord: 'SkipTraceRecord',
    Campaign: 'Campaign',
    CampaignLog: 'CampaignLog',
    CallLog: 'CallLog',
    ScrapingJob: 'ScrapingJob',
    PropertyRecord: 'PropertyRecord',
    DailyMetric: 'DailyMetric',
    ScraperJob: 'ScraperJob'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "organization" | "user" | "lead" | "leadNote" | "skipTraceRecord" | "campaign" | "campaignLog" | "callLog" | "scrapingJob" | "propertyRecord" | "dailyMetric" | "scraperJob"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      LeadNote: {
        payload: Prisma.$LeadNotePayload<ExtArgs>
        fields: Prisma.LeadNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload>
          }
          findFirst: {
            args: Prisma.LeadNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload>
          }
          findMany: {
            args: Prisma.LeadNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload>[]
          }
          create: {
            args: Prisma.LeadNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload>
          }
          createMany: {
            args: Prisma.LeadNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload>[]
          }
          delete: {
            args: Prisma.LeadNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload>
          }
          update: {
            args: Prisma.LeadNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload>
          }
          deleteMany: {
            args: Prisma.LeadNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadNotePayload>
          }
          aggregate: {
            args: Prisma.LeadNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadNote>
          }
          groupBy: {
            args: Prisma.LeadNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadNoteCountArgs<ExtArgs>
            result: $Utils.Optional<LeadNoteCountAggregateOutputType> | number
          }
        }
      }
      SkipTraceRecord: {
        payload: Prisma.$SkipTraceRecordPayload<ExtArgs>
        fields: Prisma.SkipTraceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkipTraceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkipTraceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload>
          }
          findFirst: {
            args: Prisma.SkipTraceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkipTraceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload>
          }
          findMany: {
            args: Prisma.SkipTraceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload>[]
          }
          create: {
            args: Prisma.SkipTraceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload>
          }
          createMany: {
            args: Prisma.SkipTraceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkipTraceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload>[]
          }
          delete: {
            args: Prisma.SkipTraceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload>
          }
          update: {
            args: Prisma.SkipTraceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload>
          }
          deleteMany: {
            args: Prisma.SkipTraceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkipTraceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkipTraceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkipTraceRecordPayload>
          }
          aggregate: {
            args: Prisma.SkipTraceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkipTraceRecord>
          }
          groupBy: {
            args: Prisma.SkipTraceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkipTraceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkipTraceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<SkipTraceRecordCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignLog: {
        payload: Prisma.$CampaignLogPayload<ExtArgs>
        fields: Prisma.CampaignLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          findFirst: {
            args: Prisma.CampaignLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          findMany: {
            args: Prisma.CampaignLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>[]
          }
          create: {
            args: Prisma.CampaignLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          createMany: {
            args: Prisma.CampaignLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>[]
          }
          delete: {
            args: Prisma.CampaignLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          update: {
            args: Prisma.CampaignLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          deleteMany: {
            args: Prisma.CampaignLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          aggregate: {
            args: Prisma.CampaignLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignLog>
          }
          groupBy: {
            args: Prisma.CampaignLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignLogCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignLogCountAggregateOutputType> | number
          }
        }
      }
      CallLog: {
        payload: Prisma.$CallLogPayload<ExtArgs>
        fields: Prisma.CallLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          findFirst: {
            args: Prisma.CallLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          findMany: {
            args: Prisma.CallLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>[]
          }
          create: {
            args: Prisma.CallLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          createMany: {
            args: Prisma.CallLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>[]
          }
          delete: {
            args: Prisma.CallLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          update: {
            args: Prisma.CallLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          deleteMany: {
            args: Prisma.CallLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CallLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          aggregate: {
            args: Prisma.CallLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallLog>
          }
          groupBy: {
            args: Prisma.CallLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallLogCountArgs<ExtArgs>
            result: $Utils.Optional<CallLogCountAggregateOutputType> | number
          }
        }
      }
      ScrapingJob: {
        payload: Prisma.$ScrapingJobPayload<ExtArgs>
        fields: Prisma.ScrapingJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScrapingJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScrapingJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload>
          }
          findFirst: {
            args: Prisma.ScrapingJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScrapingJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload>
          }
          findMany: {
            args: Prisma.ScrapingJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload>[]
          }
          create: {
            args: Prisma.ScrapingJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload>
          }
          createMany: {
            args: Prisma.ScrapingJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScrapingJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload>[]
          }
          delete: {
            args: Prisma.ScrapingJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload>
          }
          update: {
            args: Prisma.ScrapingJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload>
          }
          deleteMany: {
            args: Prisma.ScrapingJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScrapingJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScrapingJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrapingJobPayload>
          }
          aggregate: {
            args: Prisma.ScrapingJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScrapingJob>
          }
          groupBy: {
            args: Prisma.ScrapingJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScrapingJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScrapingJobCountArgs<ExtArgs>
            result: $Utils.Optional<ScrapingJobCountAggregateOutputType> | number
          }
        }
      }
      PropertyRecord: {
        payload: Prisma.$PropertyRecordPayload<ExtArgs>
        fields: Prisma.PropertyRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload>
          }
          findFirst: {
            args: Prisma.PropertyRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload>
          }
          findMany: {
            args: Prisma.PropertyRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload>[]
          }
          create: {
            args: Prisma.PropertyRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload>
          }
          createMany: {
            args: Prisma.PropertyRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload>[]
          }
          delete: {
            args: Prisma.PropertyRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload>
          }
          update: {
            args: Prisma.PropertyRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload>
          }
          deleteMany: {
            args: Prisma.PropertyRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyRecordPayload>
          }
          aggregate: {
            args: Prisma.PropertyRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyRecord>
          }
          groupBy: {
            args: Prisma.PropertyRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyRecordCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyRecordCountAggregateOutputType> | number
          }
        }
      }
      DailyMetric: {
        payload: Prisma.$DailyMetricPayload<ExtArgs>
        fields: Prisma.DailyMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          findFirst: {
            args: Prisma.DailyMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          findMany: {
            args: Prisma.DailyMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>[]
          }
          create: {
            args: Prisma.DailyMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          createMany: {
            args: Prisma.DailyMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>[]
          }
          delete: {
            args: Prisma.DailyMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          update: {
            args: Prisma.DailyMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          deleteMany: {
            args: Prisma.DailyMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          aggregate: {
            args: Prisma.DailyMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyMetric>
          }
          groupBy: {
            args: Prisma.DailyMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyMetricCountArgs<ExtArgs>
            result: $Utils.Optional<DailyMetricCountAggregateOutputType> | number
          }
        }
      }
      ScraperJob: {
        payload: Prisma.$ScraperJobPayload<ExtArgs>
        fields: Prisma.ScraperJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScraperJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScraperJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload>
          }
          findFirst: {
            args: Prisma.ScraperJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScraperJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload>
          }
          findMany: {
            args: Prisma.ScraperJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload>[]
          }
          create: {
            args: Prisma.ScraperJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload>
          }
          createMany: {
            args: Prisma.ScraperJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScraperJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload>[]
          }
          delete: {
            args: Prisma.ScraperJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload>
          }
          update: {
            args: Prisma.ScraperJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload>
          }
          deleteMany: {
            args: Prisma.ScraperJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScraperJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScraperJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScraperJobPayload>
          }
          aggregate: {
            args: Prisma.ScraperJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScraperJob>
          }
          groupBy: {
            args: Prisma.ScraperJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScraperJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScraperJobCountArgs<ExtArgs>
            result: $Utils.Optional<ScraperJobCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    leads: number
    campaigns: number
    callLogs: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    leads?: boolean | OrganizationCountOutputTypeCountLeadsArgs
    campaigns?: boolean | OrganizationCountOutputTypeCountCampaignsArgs
    callLogs?: boolean | OrganizationCountOutputTypeCountCallLogsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCallLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallLogWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assignedLeads: number
    callLogs: number
    campaignLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedLeads?: boolean | UserCountOutputTypeCountAssignedLeadsArgs
    callLogs?: boolean | UserCountOutputTypeCountCallLogsArgs
    campaignLogs?: boolean | UserCountOutputTypeCountCampaignLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCallLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLogWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    callLogs: number
    campaignLogs: number
    leadNotes: number
    skipTraceRecords: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callLogs?: boolean | LeadCountOutputTypeCountCallLogsArgs
    campaignLogs?: boolean | LeadCountOutputTypeCountCampaignLogsArgs
    leadNotes?: boolean | LeadCountOutputTypeCountLeadNotesArgs
    skipTraceRecords?: boolean | LeadCountOutputTypeCountSkipTraceRecordsArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountCallLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallLogWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountCampaignLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLogWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountLeadNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadNoteWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountSkipTraceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkipTraceRecordWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    campaignLogs: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaignLogs?: boolean | CampaignCountOutputTypeCountCampaignLogsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCampaignLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    monthlyLeadCount: number | null
    monthlySkipTraceCount: number | null
    monthlyCampaignCount: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    monthlyLeadCount: number | null
    monthlySkipTraceCount: number | null
    monthlyCampaignCount: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    plan: string | null
    createdAt: Date | null
    updatedAt: Date | null
    monthlyLeadCount: number | null
    monthlySkipTraceCount: number | null
    monthlyCampaignCount: number | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    plan: string | null
    createdAt: Date | null
    updatedAt: Date | null
    monthlyLeadCount: number | null
    monthlySkipTraceCount: number | null
    monthlyCampaignCount: number | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    plan: number
    createdAt: number
    updatedAt: number
    monthlyLeadCount: number
    monthlySkipTraceCount: number
    monthlyCampaignCount: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    monthlyLeadCount?: true
    monthlySkipTraceCount?: true
    monthlyCampaignCount?: true
  }

  export type OrganizationSumAggregateInputType = {
    monthlyLeadCount?: true
    monthlySkipTraceCount?: true
    monthlyCampaignCount?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
    monthlyLeadCount?: true
    monthlySkipTraceCount?: true
    monthlyCampaignCount?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
    monthlyLeadCount?: true
    monthlySkipTraceCount?: true
    monthlyCampaignCount?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
    monthlyLeadCount?: true
    monthlySkipTraceCount?: true
    monthlyCampaignCount?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    plan: string
    createdAt: Date
    updatedAt: Date
    monthlyLeadCount: number
    monthlySkipTraceCount: number
    monthlyCampaignCount: number
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthlyLeadCount?: boolean
    monthlySkipTraceCount?: boolean
    monthlyCampaignCount?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    leads?: boolean | Organization$leadsArgs<ExtArgs>
    campaigns?: boolean | Organization$campaignsArgs<ExtArgs>
    callLogs?: boolean | Organization$callLogsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthlyLeadCount?: boolean
    monthlySkipTraceCount?: boolean
    monthlyCampaignCount?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    plan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    monthlyLeadCount?: boolean
    monthlySkipTraceCount?: boolean
    monthlyCampaignCount?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    leads?: boolean | Organization$leadsArgs<ExtArgs>
    campaigns?: boolean | Organization$campaignsArgs<ExtArgs>
    callLogs?: boolean | Organization$callLogsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      callLogs: Prisma.$CallLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      plan: string
      createdAt: Date
      updatedAt: Date
      monthlyLeadCount: number
      monthlySkipTraceCount: number
      monthlyCampaignCount: number
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    leads<T extends Organization$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    campaigns<T extends Organization$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    callLogs<T extends Organization$callLogsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$callLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly plan: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly monthlyLeadCount: FieldRef<"Organization", 'Int'>
    readonly monthlySkipTraceCount: FieldRef<"Organization", 'Int'>
    readonly monthlyCampaignCount: FieldRef<"Organization", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.leads
   */
  export type Organization$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Organization.campaigns
   */
  export type Organization$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Organization.callLogs
   */
  export type Organization$callLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    where?: CallLogWhereInput
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    cursor?: CallLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    isActive: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    organizationId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: string
    isActive: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    organizationId: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    assignedLeads?: boolean | User$assignedLeadsArgs<ExtArgs>
    callLogs?: boolean | User$callLogsArgs<ExtArgs>
    campaignLogs?: boolean | User$campaignLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    assignedLeads?: boolean | User$assignedLeadsArgs<ExtArgs>
    callLogs?: boolean | User$callLogsArgs<ExtArgs>
    campaignLogs?: boolean | User$campaignLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      assignedLeads: Prisma.$LeadPayload<ExtArgs>[]
      callLogs: Prisma.$CallLogPayload<ExtArgs>[]
      campaignLogs: Prisma.$CampaignLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      role: string
      isActive: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      organizationId: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedLeads<T extends User$assignedLeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    callLogs<T extends User$callLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$callLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findMany"> | Null>
    campaignLogs<T extends User$campaignLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly organizationId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.assignedLeads
   */
  export type User$assignedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * User.callLogs
   */
  export type User$callLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    where?: CallLogWhereInput
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    cursor?: CallLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * User.campaignLogs
   */
  export type User$campaignLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    where?: CampaignLogWhereInput
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    cursor?: CampaignLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    bedrooms: number | null
    bathrooms: number | null
    squareFootage: number | null
    lotSize: number | null
    yearBuilt: number | null
    listPrice: number | null
    arv: number | null
    estimatedValue: number | null
    estimatedRepairs: number | null
    marketValue: number | null
    loanAmount: number | null
    equity: number | null
    equityPercent: number | null
    lastSalePrice: number | null
    taxAssessedValue: number | null
    skipTraceCostCents: number | null
    motivationScore: number | null
    timeOnMarket: number | null
    priceReductions: number | null
    aiScore: number | null
    aiCostCents: number | null
    profitEstimate: number | null
  }

  export type LeadSumAggregateOutputType = {
    bedrooms: number | null
    bathrooms: number | null
    squareFootage: number | null
    lotSize: number | null
    yearBuilt: number | null
    listPrice: number | null
    arv: number | null
    estimatedValue: number | null
    estimatedRepairs: number | null
    marketValue: number | null
    loanAmount: number | null
    equity: number | null
    equityPercent: number | null
    lastSalePrice: number | null
    taxAssessedValue: number | null
    skipTraceCostCents: number | null
    motivationScore: number | null
    timeOnMarket: number | null
    priceReductions: number | null
    aiScore: number | null
    aiCostCents: number | null
    profitEstimate: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    status: string | null
    source: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
    propertyAddress: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    propertyType: string | null
    bedrooms: number | null
    bathrooms: number | null
    squareFootage: number | null
    lotSize: number | null
    yearBuilt: number | null
    normalizedAddress: string | null
    listPrice: number | null
    arv: number | null
    estimatedValue: number | null
    estimatedRepairs: number | null
    marketValue: number | null
    loanAmount: number | null
    equity: number | null
    equityPercent: number | null
    lastSalePrice: number | null
    lastSaleDate: Date | null
    taxAssessedValue: number | null
    ownerName: string | null
    ownerPhone: string | null
    ownerEmail: string | null
    ownerAddress: string | null
    isAbsenteeOwner: boolean | null
    phonesJson: string | null
    emailsJson: string | null
    skipTraceProvider: string | null
    skipTraceCostCents: number | null
    skipTracedAt: Date | null
    dncFlag: boolean | null
    motivationScore: number | null
    motivationFactors: string | null
    distressSignals: string | null
    timeOnMarket: number | null
    priceReductions: number | null
    aiScore: number | null
    aiCostCents: number | null
    aiScoredAt: Date | null
    aiSummary: string | null
    dealPotential: string | null
    profitEstimate: number | null
    temperatureTag: string | null
    tags: string | null
    isActive: boolean | null
    organizationId: string | null
    assignedToId: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    status: string | null
    source: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
    propertyAddress: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    propertyType: string | null
    bedrooms: number | null
    bathrooms: number | null
    squareFootage: number | null
    lotSize: number | null
    yearBuilt: number | null
    normalizedAddress: string | null
    listPrice: number | null
    arv: number | null
    estimatedValue: number | null
    estimatedRepairs: number | null
    marketValue: number | null
    loanAmount: number | null
    equity: number | null
    equityPercent: number | null
    lastSalePrice: number | null
    lastSaleDate: Date | null
    taxAssessedValue: number | null
    ownerName: string | null
    ownerPhone: string | null
    ownerEmail: string | null
    ownerAddress: string | null
    isAbsenteeOwner: boolean | null
    phonesJson: string | null
    emailsJson: string | null
    skipTraceProvider: string | null
    skipTraceCostCents: number | null
    skipTracedAt: Date | null
    dncFlag: boolean | null
    motivationScore: number | null
    motivationFactors: string | null
    distressSignals: string | null
    timeOnMarket: number | null
    priceReductions: number | null
    aiScore: number | null
    aiCostCents: number | null
    aiScoredAt: Date | null
    aiSummary: string | null
    dealPotential: string | null
    profitEstimate: number | null
    temperatureTag: string | null
    tags: string | null
    isActive: boolean | null
    organizationId: string | null
    assignedToId: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    status: number
    source: number
    priority: number
    createdAt: number
    updatedAt: number
    propertyAddress: number
    city: number
    state: number
    zipCode: number
    propertyType: number
    bedrooms: number
    bathrooms: number
    squareFootage: number
    lotSize: number
    yearBuilt: number
    normalizedAddress: number
    listPrice: number
    arv: number
    estimatedValue: number
    estimatedRepairs: number
    marketValue: number
    loanAmount: number
    equity: number
    equityPercent: number
    lastSalePrice: number
    lastSaleDate: number
    taxAssessedValue: number
    ownerName: number
    ownerPhone: number
    ownerEmail: number
    ownerAddress: number
    isAbsenteeOwner: number
    phonesJson: number
    emailsJson: number
    skipTraceProvider: number
    skipTraceCostCents: number
    skipTracedAt: number
    dncFlag: number
    motivationScore: number
    motivationFactors: number
    distressSignals: number
    timeOnMarket: number
    priceReductions: number
    aiScore: number
    aiCostCents: number
    aiScoredAt: number
    aiSummary: number
    dealPotential: number
    profitEstimate: number
    temperatureTag: number
    tags: number
    isActive: number
    organizationId: number
    assignedToId: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    bedrooms?: true
    bathrooms?: true
    squareFootage?: true
    lotSize?: true
    yearBuilt?: true
    listPrice?: true
    arv?: true
    estimatedValue?: true
    estimatedRepairs?: true
    marketValue?: true
    loanAmount?: true
    equity?: true
    equityPercent?: true
    lastSalePrice?: true
    taxAssessedValue?: true
    skipTraceCostCents?: true
    motivationScore?: true
    timeOnMarket?: true
    priceReductions?: true
    aiScore?: true
    aiCostCents?: true
    profitEstimate?: true
  }

  export type LeadSumAggregateInputType = {
    bedrooms?: true
    bathrooms?: true
    squareFootage?: true
    lotSize?: true
    yearBuilt?: true
    listPrice?: true
    arv?: true
    estimatedValue?: true
    estimatedRepairs?: true
    marketValue?: true
    loanAmount?: true
    equity?: true
    equityPercent?: true
    lastSalePrice?: true
    taxAssessedValue?: true
    skipTraceCostCents?: true
    motivationScore?: true
    timeOnMarket?: true
    priceReductions?: true
    aiScore?: true
    aiCostCents?: true
    profitEstimate?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    status?: true
    source?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    propertyAddress?: true
    city?: true
    state?: true
    zipCode?: true
    propertyType?: true
    bedrooms?: true
    bathrooms?: true
    squareFootage?: true
    lotSize?: true
    yearBuilt?: true
    normalizedAddress?: true
    listPrice?: true
    arv?: true
    estimatedValue?: true
    estimatedRepairs?: true
    marketValue?: true
    loanAmount?: true
    equity?: true
    equityPercent?: true
    lastSalePrice?: true
    lastSaleDate?: true
    taxAssessedValue?: true
    ownerName?: true
    ownerPhone?: true
    ownerEmail?: true
    ownerAddress?: true
    isAbsenteeOwner?: true
    phonesJson?: true
    emailsJson?: true
    skipTraceProvider?: true
    skipTraceCostCents?: true
    skipTracedAt?: true
    dncFlag?: true
    motivationScore?: true
    motivationFactors?: true
    distressSignals?: true
    timeOnMarket?: true
    priceReductions?: true
    aiScore?: true
    aiCostCents?: true
    aiScoredAt?: true
    aiSummary?: true
    dealPotential?: true
    profitEstimate?: true
    temperatureTag?: true
    tags?: true
    isActive?: true
    organizationId?: true
    assignedToId?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    status?: true
    source?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    propertyAddress?: true
    city?: true
    state?: true
    zipCode?: true
    propertyType?: true
    bedrooms?: true
    bathrooms?: true
    squareFootage?: true
    lotSize?: true
    yearBuilt?: true
    normalizedAddress?: true
    listPrice?: true
    arv?: true
    estimatedValue?: true
    estimatedRepairs?: true
    marketValue?: true
    loanAmount?: true
    equity?: true
    equityPercent?: true
    lastSalePrice?: true
    lastSaleDate?: true
    taxAssessedValue?: true
    ownerName?: true
    ownerPhone?: true
    ownerEmail?: true
    ownerAddress?: true
    isAbsenteeOwner?: true
    phonesJson?: true
    emailsJson?: true
    skipTraceProvider?: true
    skipTraceCostCents?: true
    skipTracedAt?: true
    dncFlag?: true
    motivationScore?: true
    motivationFactors?: true
    distressSignals?: true
    timeOnMarket?: true
    priceReductions?: true
    aiScore?: true
    aiCostCents?: true
    aiScoredAt?: true
    aiSummary?: true
    dealPotential?: true
    profitEstimate?: true
    temperatureTag?: true
    tags?: true
    isActive?: true
    organizationId?: true
    assignedToId?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    status?: true
    source?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    propertyAddress?: true
    city?: true
    state?: true
    zipCode?: true
    propertyType?: true
    bedrooms?: true
    bathrooms?: true
    squareFootage?: true
    lotSize?: true
    yearBuilt?: true
    normalizedAddress?: true
    listPrice?: true
    arv?: true
    estimatedValue?: true
    estimatedRepairs?: true
    marketValue?: true
    loanAmount?: true
    equity?: true
    equityPercent?: true
    lastSalePrice?: true
    lastSaleDate?: true
    taxAssessedValue?: true
    ownerName?: true
    ownerPhone?: true
    ownerEmail?: true
    ownerAddress?: true
    isAbsenteeOwner?: true
    phonesJson?: true
    emailsJson?: true
    skipTraceProvider?: true
    skipTraceCostCents?: true
    skipTracedAt?: true
    dncFlag?: true
    motivationScore?: true
    motivationFactors?: true
    distressSignals?: true
    timeOnMarket?: true
    priceReductions?: true
    aiScore?: true
    aiCostCents?: true
    aiScoredAt?: true
    aiSummary?: true
    dealPotential?: true
    profitEstimate?: true
    temperatureTag?: true
    tags?: true
    isActive?: true
    organizationId?: true
    assignedToId?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    status: string
    source: string
    priority: string
    createdAt: Date
    updatedAt: Date
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType: string | null
    bedrooms: number | null
    bathrooms: number | null
    squareFootage: number | null
    lotSize: number | null
    yearBuilt: number | null
    normalizedAddress: string | null
    listPrice: number | null
    arv: number | null
    estimatedValue: number | null
    estimatedRepairs: number | null
    marketValue: number | null
    loanAmount: number | null
    equity: number | null
    equityPercent: number | null
    lastSalePrice: number | null
    lastSaleDate: Date | null
    taxAssessedValue: number | null
    ownerName: string | null
    ownerPhone: string | null
    ownerEmail: string | null
    ownerAddress: string | null
    isAbsenteeOwner: boolean
    phonesJson: string | null
    emailsJson: string | null
    skipTraceProvider: string | null
    skipTraceCostCents: number | null
    skipTracedAt: Date | null
    dncFlag: boolean
    motivationScore: number | null
    motivationFactors: string | null
    distressSignals: string | null
    timeOnMarket: number | null
    priceReductions: number | null
    aiScore: number | null
    aiCostCents: number | null
    aiScoredAt: Date | null
    aiSummary: string | null
    dealPotential: string | null
    profitEstimate: number | null
    temperatureTag: string | null
    tags: string
    isActive: boolean
    organizationId: string
    assignedToId: string | null
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    source?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyAddress?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    propertyType?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareFootage?: boolean
    lotSize?: boolean
    yearBuilt?: boolean
    normalizedAddress?: boolean
    listPrice?: boolean
    arv?: boolean
    estimatedValue?: boolean
    estimatedRepairs?: boolean
    marketValue?: boolean
    loanAmount?: boolean
    equity?: boolean
    equityPercent?: boolean
    lastSalePrice?: boolean
    lastSaleDate?: boolean
    taxAssessedValue?: boolean
    ownerName?: boolean
    ownerPhone?: boolean
    ownerEmail?: boolean
    ownerAddress?: boolean
    isAbsenteeOwner?: boolean
    phonesJson?: boolean
    emailsJson?: boolean
    skipTraceProvider?: boolean
    skipTraceCostCents?: boolean
    skipTracedAt?: boolean
    dncFlag?: boolean
    motivationScore?: boolean
    motivationFactors?: boolean
    distressSignals?: boolean
    timeOnMarket?: boolean
    priceReductions?: boolean
    aiScore?: boolean
    aiCostCents?: boolean
    aiScoredAt?: boolean
    aiSummary?: boolean
    dealPotential?: boolean
    profitEstimate?: boolean
    temperatureTag?: boolean
    tags?: boolean
    isActive?: boolean
    organizationId?: boolean
    assignedToId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    assignedTo?: boolean | Lead$assignedToArgs<ExtArgs>
    callLogs?: boolean | Lead$callLogsArgs<ExtArgs>
    campaignLogs?: boolean | Lead$campaignLogsArgs<ExtArgs>
    leadNotes?: boolean | Lead$leadNotesArgs<ExtArgs>
    skipTraceRecords?: boolean | Lead$skipTraceRecordsArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    source?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyAddress?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    propertyType?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareFootage?: boolean
    lotSize?: boolean
    yearBuilt?: boolean
    normalizedAddress?: boolean
    listPrice?: boolean
    arv?: boolean
    estimatedValue?: boolean
    estimatedRepairs?: boolean
    marketValue?: boolean
    loanAmount?: boolean
    equity?: boolean
    equityPercent?: boolean
    lastSalePrice?: boolean
    lastSaleDate?: boolean
    taxAssessedValue?: boolean
    ownerName?: boolean
    ownerPhone?: boolean
    ownerEmail?: boolean
    ownerAddress?: boolean
    isAbsenteeOwner?: boolean
    phonesJson?: boolean
    emailsJson?: boolean
    skipTraceProvider?: boolean
    skipTraceCostCents?: boolean
    skipTracedAt?: boolean
    dncFlag?: boolean
    motivationScore?: boolean
    motivationFactors?: boolean
    distressSignals?: boolean
    timeOnMarket?: boolean
    priceReductions?: boolean
    aiScore?: boolean
    aiCostCents?: boolean
    aiScoredAt?: boolean
    aiSummary?: boolean
    dealPotential?: boolean
    profitEstimate?: boolean
    temperatureTag?: boolean
    tags?: boolean
    isActive?: boolean
    organizationId?: boolean
    assignedToId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    assignedTo?: boolean | Lead$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    status?: boolean
    source?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyAddress?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    propertyType?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareFootage?: boolean
    lotSize?: boolean
    yearBuilt?: boolean
    normalizedAddress?: boolean
    listPrice?: boolean
    arv?: boolean
    estimatedValue?: boolean
    estimatedRepairs?: boolean
    marketValue?: boolean
    loanAmount?: boolean
    equity?: boolean
    equityPercent?: boolean
    lastSalePrice?: boolean
    lastSaleDate?: boolean
    taxAssessedValue?: boolean
    ownerName?: boolean
    ownerPhone?: boolean
    ownerEmail?: boolean
    ownerAddress?: boolean
    isAbsenteeOwner?: boolean
    phonesJson?: boolean
    emailsJson?: boolean
    skipTraceProvider?: boolean
    skipTraceCostCents?: boolean
    skipTracedAt?: boolean
    dncFlag?: boolean
    motivationScore?: boolean
    motivationFactors?: boolean
    distressSignals?: boolean
    timeOnMarket?: boolean
    priceReductions?: boolean
    aiScore?: boolean
    aiCostCents?: boolean
    aiScoredAt?: boolean
    aiSummary?: boolean
    dealPotential?: boolean
    profitEstimate?: boolean
    temperatureTag?: boolean
    tags?: boolean
    isActive?: boolean
    organizationId?: boolean
    assignedToId?: boolean
  }

  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    assignedTo?: boolean | Lead$assignedToArgs<ExtArgs>
    callLogs?: boolean | Lead$callLogsArgs<ExtArgs>
    campaignLogs?: boolean | Lead$campaignLogsArgs<ExtArgs>
    leadNotes?: boolean | Lead$leadNotesArgs<ExtArgs>
    skipTraceRecords?: boolean | Lead$skipTraceRecordsArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    assignedTo?: boolean | Lead$assignedToArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      callLogs: Prisma.$CallLogPayload<ExtArgs>[]
      campaignLogs: Prisma.$CampaignLogPayload<ExtArgs>[]
      leadNotes: Prisma.$LeadNotePayload<ExtArgs>[]
      skipTraceRecords: Prisma.$SkipTraceRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      source: string
      priority: string
      createdAt: Date
      updatedAt: Date
      propertyAddress: string
      city: string
      state: string
      zipCode: string
      propertyType: string | null
      bedrooms: number | null
      bathrooms: number | null
      squareFootage: number | null
      lotSize: number | null
      yearBuilt: number | null
      normalizedAddress: string | null
      listPrice: number | null
      arv: number | null
      estimatedValue: number | null
      estimatedRepairs: number | null
      marketValue: number | null
      loanAmount: number | null
      equity: number | null
      equityPercent: number | null
      lastSalePrice: number | null
      lastSaleDate: Date | null
      taxAssessedValue: number | null
      ownerName: string | null
      ownerPhone: string | null
      ownerEmail: string | null
      ownerAddress: string | null
      isAbsenteeOwner: boolean
      phonesJson: string | null
      emailsJson: string | null
      skipTraceProvider: string | null
      skipTraceCostCents: number | null
      skipTracedAt: Date | null
      dncFlag: boolean
      motivationScore: number | null
      motivationFactors: string | null
      distressSignals: string | null
      timeOnMarket: number | null
      priceReductions: number | null
      aiScore: number | null
      aiCostCents: number | null
      aiScoredAt: Date | null
      aiSummary: string | null
      dealPotential: string | null
      profitEstimate: number | null
      temperatureTag: string | null
      tags: string
      isActive: boolean
      organizationId: string
      assignedToId: string | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTo<T extends Lead$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Lead$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    callLogs<T extends Lead$callLogsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$callLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findMany"> | Null>
    campaignLogs<T extends Lead$campaignLogsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$campaignLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findMany"> | Null>
    leadNotes<T extends Lead$leadNotesArgs<ExtArgs> = {}>(args?: Subset<T, Lead$leadNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "findMany"> | Null>
    skipTraceRecords<T extends Lead$skipTraceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$skipTraceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'String'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly priority: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
    readonly propertyAddress: FieldRef<"Lead", 'String'>
    readonly city: FieldRef<"Lead", 'String'>
    readonly state: FieldRef<"Lead", 'String'>
    readonly zipCode: FieldRef<"Lead", 'String'>
    readonly propertyType: FieldRef<"Lead", 'String'>
    readonly bedrooms: FieldRef<"Lead", 'Int'>
    readonly bathrooms: FieldRef<"Lead", 'Float'>
    readonly squareFootage: FieldRef<"Lead", 'Int'>
    readonly lotSize: FieldRef<"Lead", 'Float'>
    readonly yearBuilt: FieldRef<"Lead", 'Int'>
    readonly normalizedAddress: FieldRef<"Lead", 'String'>
    readonly listPrice: FieldRef<"Lead", 'Float'>
    readonly arv: FieldRef<"Lead", 'Float'>
    readonly estimatedValue: FieldRef<"Lead", 'Int'>
    readonly estimatedRepairs: FieldRef<"Lead", 'Float'>
    readonly marketValue: FieldRef<"Lead", 'Float'>
    readonly loanAmount: FieldRef<"Lead", 'Float'>
    readonly equity: FieldRef<"Lead", 'Int'>
    readonly equityPercent: FieldRef<"Lead", 'Float'>
    readonly lastSalePrice: FieldRef<"Lead", 'Float'>
    readonly lastSaleDate: FieldRef<"Lead", 'DateTime'>
    readonly taxAssessedValue: FieldRef<"Lead", 'Float'>
    readonly ownerName: FieldRef<"Lead", 'String'>
    readonly ownerPhone: FieldRef<"Lead", 'String'>
    readonly ownerEmail: FieldRef<"Lead", 'String'>
    readonly ownerAddress: FieldRef<"Lead", 'String'>
    readonly isAbsenteeOwner: FieldRef<"Lead", 'Boolean'>
    readonly phonesJson: FieldRef<"Lead", 'String'>
    readonly emailsJson: FieldRef<"Lead", 'String'>
    readonly skipTraceProvider: FieldRef<"Lead", 'String'>
    readonly skipTraceCostCents: FieldRef<"Lead", 'Int'>
    readonly skipTracedAt: FieldRef<"Lead", 'DateTime'>
    readonly dncFlag: FieldRef<"Lead", 'Boolean'>
    readonly motivationScore: FieldRef<"Lead", 'Float'>
    readonly motivationFactors: FieldRef<"Lead", 'String'>
    readonly distressSignals: FieldRef<"Lead", 'String'>
    readonly timeOnMarket: FieldRef<"Lead", 'Int'>
    readonly priceReductions: FieldRef<"Lead", 'Int'>
    readonly aiScore: FieldRef<"Lead", 'Int'>
    readonly aiCostCents: FieldRef<"Lead", 'Int'>
    readonly aiScoredAt: FieldRef<"Lead", 'DateTime'>
    readonly aiSummary: FieldRef<"Lead", 'String'>
    readonly dealPotential: FieldRef<"Lead", 'String'>
    readonly profitEstimate: FieldRef<"Lead", 'Float'>
    readonly temperatureTag: FieldRef<"Lead", 'String'>
    readonly tags: FieldRef<"Lead", 'String'>
    readonly isActive: FieldRef<"Lead", 'Boolean'>
    readonly organizationId: FieldRef<"Lead", 'String'>
    readonly assignedToId: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }

  /**
   * Lead.assignedTo
   */
  export type Lead$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Lead.callLogs
   */
  export type Lead$callLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    where?: CallLogWhereInput
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    cursor?: CallLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * Lead.campaignLogs
   */
  export type Lead$campaignLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    where?: CampaignLogWhereInput
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    cursor?: CampaignLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * Lead.leadNotes
   */
  export type Lead$leadNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    where?: LeadNoteWhereInput
    orderBy?: LeadNoteOrderByWithRelationInput | LeadNoteOrderByWithRelationInput[]
    cursor?: LeadNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadNoteScalarFieldEnum | LeadNoteScalarFieldEnum[]
  }

  /**
   * Lead.skipTraceRecords
   */
  export type Lead$skipTraceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    where?: SkipTraceRecordWhereInput
    orderBy?: SkipTraceRecordOrderByWithRelationInput | SkipTraceRecordOrderByWithRelationInput[]
    cursor?: SkipTraceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkipTraceRecordScalarFieldEnum | SkipTraceRecordScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model LeadNote
   */

  export type AggregateLeadNote = {
    _count: LeadNoteCountAggregateOutputType | null
    _min: LeadNoteMinAggregateOutputType | null
    _max: LeadNoteMaxAggregateOutputType | null
  }

  export type LeadNoteMinAggregateOutputType = {
    id: string | null
    content: string | null
    type: string | null
    createdAt: Date | null
    leadId: string | null
  }

  export type LeadNoteMaxAggregateOutputType = {
    id: string | null
    content: string | null
    type: string | null
    createdAt: Date | null
    leadId: string | null
  }

  export type LeadNoteCountAggregateOutputType = {
    id: number
    content: number
    type: number
    createdAt: number
    leadId: number
    _all: number
  }


  export type LeadNoteMinAggregateInputType = {
    id?: true
    content?: true
    type?: true
    createdAt?: true
    leadId?: true
  }

  export type LeadNoteMaxAggregateInputType = {
    id?: true
    content?: true
    type?: true
    createdAt?: true
    leadId?: true
  }

  export type LeadNoteCountAggregateInputType = {
    id?: true
    content?: true
    type?: true
    createdAt?: true
    leadId?: true
    _all?: true
  }

  export type LeadNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadNote to aggregate.
     */
    where?: LeadNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadNotes to fetch.
     */
    orderBy?: LeadNoteOrderByWithRelationInput | LeadNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadNotes
    **/
    _count?: true | LeadNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadNoteMaxAggregateInputType
  }

  export type GetLeadNoteAggregateType<T extends LeadNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadNote[P]>
      : GetScalarType<T[P], AggregateLeadNote[P]>
  }




  export type LeadNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadNoteWhereInput
    orderBy?: LeadNoteOrderByWithAggregationInput | LeadNoteOrderByWithAggregationInput[]
    by: LeadNoteScalarFieldEnum[] | LeadNoteScalarFieldEnum
    having?: LeadNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadNoteCountAggregateInputType | true
    _min?: LeadNoteMinAggregateInputType
    _max?: LeadNoteMaxAggregateInputType
  }

  export type LeadNoteGroupByOutputType = {
    id: string
    content: string
    type: string
    createdAt: Date
    leadId: string
    _count: LeadNoteCountAggregateOutputType | null
    _min: LeadNoteMinAggregateOutputType | null
    _max: LeadNoteMaxAggregateOutputType | null
  }

  type GetLeadNoteGroupByPayload<T extends LeadNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadNoteGroupByOutputType[P]>
            : GetScalarType<T[P], LeadNoteGroupByOutputType[P]>
        }
      >
    >


  export type LeadNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    leadId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadNote"]>

  export type LeadNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    leadId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadNote"]>

  export type LeadNoteSelectScalar = {
    id?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    leadId?: boolean
  }

  export type LeadNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type LeadNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $LeadNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadNote"
    objects: {
      lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      type: string
      createdAt: Date
      leadId: string
    }, ExtArgs["result"]["leadNote"]>
    composites: {}
  }

  type LeadNoteGetPayload<S extends boolean | null | undefined | LeadNoteDefaultArgs> = $Result.GetResult<Prisma.$LeadNotePayload, S>

  type LeadNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadNoteCountAggregateInputType | true
    }

  export interface LeadNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadNote'], meta: { name: 'LeadNote' } }
    /**
     * Find zero or one LeadNote that matches the filter.
     * @param {LeadNoteFindUniqueArgs} args - Arguments to find a LeadNote
     * @example
     * // Get one LeadNote
     * const leadNote = await prisma.leadNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadNoteFindUniqueArgs>(args: SelectSubset<T, LeadNoteFindUniqueArgs<ExtArgs>>): Prisma__LeadNoteClient<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeadNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadNoteFindUniqueOrThrowArgs} args - Arguments to find a LeadNote
     * @example
     * // Get one LeadNote
     * const leadNote = await prisma.leadNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadNoteClient<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeadNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadNoteFindFirstArgs} args - Arguments to find a LeadNote
     * @example
     * // Get one LeadNote
     * const leadNote = await prisma.leadNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadNoteFindFirstArgs>(args?: SelectSubset<T, LeadNoteFindFirstArgs<ExtArgs>>): Prisma__LeadNoteClient<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeadNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadNoteFindFirstOrThrowArgs} args - Arguments to find a LeadNote
     * @example
     * // Get one LeadNote
     * const leadNote = await prisma.leadNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadNoteClient<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeadNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadNotes
     * const leadNotes = await prisma.leadNote.findMany()
     * 
     * // Get first 10 LeadNotes
     * const leadNotes = await prisma.leadNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadNoteWithIdOnly = await prisma.leadNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadNoteFindManyArgs>(args?: SelectSubset<T, LeadNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeadNote.
     * @param {LeadNoteCreateArgs} args - Arguments to create a LeadNote.
     * @example
     * // Create one LeadNote
     * const LeadNote = await prisma.leadNote.create({
     *   data: {
     *     // ... data to create a LeadNote
     *   }
     * })
     * 
     */
    create<T extends LeadNoteCreateArgs>(args: SelectSubset<T, LeadNoteCreateArgs<ExtArgs>>): Prisma__LeadNoteClient<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeadNotes.
     * @param {LeadNoteCreateManyArgs} args - Arguments to create many LeadNotes.
     * @example
     * // Create many LeadNotes
     * const leadNote = await prisma.leadNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadNoteCreateManyArgs>(args?: SelectSubset<T, LeadNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadNotes and returns the data saved in the database.
     * @param {LeadNoteCreateManyAndReturnArgs} args - Arguments to create many LeadNotes.
     * @example
     * // Create many LeadNotes
     * const leadNote = await prisma.leadNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadNotes and only return the `id`
     * const leadNoteWithIdOnly = await prisma.leadNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeadNote.
     * @param {LeadNoteDeleteArgs} args - Arguments to delete one LeadNote.
     * @example
     * // Delete one LeadNote
     * const LeadNote = await prisma.leadNote.delete({
     *   where: {
     *     // ... filter to delete one LeadNote
     *   }
     * })
     * 
     */
    delete<T extends LeadNoteDeleteArgs>(args: SelectSubset<T, LeadNoteDeleteArgs<ExtArgs>>): Prisma__LeadNoteClient<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeadNote.
     * @param {LeadNoteUpdateArgs} args - Arguments to update one LeadNote.
     * @example
     * // Update one LeadNote
     * const leadNote = await prisma.leadNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadNoteUpdateArgs>(args: SelectSubset<T, LeadNoteUpdateArgs<ExtArgs>>): Prisma__LeadNoteClient<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeadNotes.
     * @param {LeadNoteDeleteManyArgs} args - Arguments to filter LeadNotes to delete.
     * @example
     * // Delete a few LeadNotes
     * const { count } = await prisma.leadNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadNoteDeleteManyArgs>(args?: SelectSubset<T, LeadNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadNotes
     * const leadNote = await prisma.leadNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadNoteUpdateManyArgs>(args: SelectSubset<T, LeadNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeadNote.
     * @param {LeadNoteUpsertArgs} args - Arguments to update or create a LeadNote.
     * @example
     * // Update or create a LeadNote
     * const leadNote = await prisma.leadNote.upsert({
     *   create: {
     *     // ... data to create a LeadNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadNote we want to update
     *   }
     * })
     */
    upsert<T extends LeadNoteUpsertArgs>(args: SelectSubset<T, LeadNoteUpsertArgs<ExtArgs>>): Prisma__LeadNoteClient<$Result.GetResult<Prisma.$LeadNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeadNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadNoteCountArgs} args - Arguments to filter LeadNotes to count.
     * @example
     * // Count the number of LeadNotes
     * const count = await prisma.leadNote.count({
     *   where: {
     *     // ... the filter for the LeadNotes we want to count
     *   }
     * })
    **/
    count<T extends LeadNoteCountArgs>(
      args?: Subset<T, LeadNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadNoteAggregateArgs>(args: Subset<T, LeadNoteAggregateArgs>): Prisma.PrismaPromise<GetLeadNoteAggregateType<T>>

    /**
     * Group by LeadNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadNoteGroupByArgs['orderBy'] }
        : { orderBy?: LeadNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadNote model
   */
  readonly fields: LeadNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadNote model
   */ 
  interface LeadNoteFieldRefs {
    readonly id: FieldRef<"LeadNote", 'String'>
    readonly content: FieldRef<"LeadNote", 'String'>
    readonly type: FieldRef<"LeadNote", 'String'>
    readonly createdAt: FieldRef<"LeadNote", 'DateTime'>
    readonly leadId: FieldRef<"LeadNote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LeadNote findUnique
   */
  export type LeadNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * Filter, which LeadNote to fetch.
     */
    where: LeadNoteWhereUniqueInput
  }

  /**
   * LeadNote findUniqueOrThrow
   */
  export type LeadNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * Filter, which LeadNote to fetch.
     */
    where: LeadNoteWhereUniqueInput
  }

  /**
   * LeadNote findFirst
   */
  export type LeadNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * Filter, which LeadNote to fetch.
     */
    where?: LeadNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadNotes to fetch.
     */
    orderBy?: LeadNoteOrderByWithRelationInput | LeadNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadNotes.
     */
    cursor?: LeadNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadNotes.
     */
    distinct?: LeadNoteScalarFieldEnum | LeadNoteScalarFieldEnum[]
  }

  /**
   * LeadNote findFirstOrThrow
   */
  export type LeadNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * Filter, which LeadNote to fetch.
     */
    where?: LeadNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadNotes to fetch.
     */
    orderBy?: LeadNoteOrderByWithRelationInput | LeadNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadNotes.
     */
    cursor?: LeadNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadNotes.
     */
    distinct?: LeadNoteScalarFieldEnum | LeadNoteScalarFieldEnum[]
  }

  /**
   * LeadNote findMany
   */
  export type LeadNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * Filter, which LeadNotes to fetch.
     */
    where?: LeadNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadNotes to fetch.
     */
    orderBy?: LeadNoteOrderByWithRelationInput | LeadNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadNotes.
     */
    cursor?: LeadNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadNotes.
     */
    skip?: number
    distinct?: LeadNoteScalarFieldEnum | LeadNoteScalarFieldEnum[]
  }

  /**
   * LeadNote create
   */
  export type LeadNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadNote.
     */
    data: XOR<LeadNoteCreateInput, LeadNoteUncheckedCreateInput>
  }

  /**
   * LeadNote createMany
   */
  export type LeadNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadNotes.
     */
    data: LeadNoteCreateManyInput | LeadNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadNote createManyAndReturn
   */
  export type LeadNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeadNotes.
     */
    data: LeadNoteCreateManyInput | LeadNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadNote update
   */
  export type LeadNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadNote.
     */
    data: XOR<LeadNoteUpdateInput, LeadNoteUncheckedUpdateInput>
    /**
     * Choose, which LeadNote to update.
     */
    where: LeadNoteWhereUniqueInput
  }

  /**
   * LeadNote updateMany
   */
  export type LeadNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadNotes.
     */
    data: XOR<LeadNoteUpdateManyMutationInput, LeadNoteUncheckedUpdateManyInput>
    /**
     * Filter which LeadNotes to update
     */
    where?: LeadNoteWhereInput
  }

  /**
   * LeadNote upsert
   */
  export type LeadNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadNote to update in case it exists.
     */
    where: LeadNoteWhereUniqueInput
    /**
     * In case the LeadNote found by the `where` argument doesn't exist, create a new LeadNote with this data.
     */
    create: XOR<LeadNoteCreateInput, LeadNoteUncheckedCreateInput>
    /**
     * In case the LeadNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadNoteUpdateInput, LeadNoteUncheckedUpdateInput>
  }

  /**
   * LeadNote delete
   */
  export type LeadNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
    /**
     * Filter which LeadNote to delete.
     */
    where: LeadNoteWhereUniqueInput
  }

  /**
   * LeadNote deleteMany
   */
  export type LeadNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadNotes to delete
     */
    where?: LeadNoteWhereInput
  }

  /**
   * LeadNote without action
   */
  export type LeadNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadNote
     */
    select?: LeadNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadNoteInclude<ExtArgs> | null
  }


  /**
   * Model SkipTraceRecord
   */

  export type AggregateSkipTraceRecord = {
    _count: SkipTraceRecordCountAggregateOutputType | null
    _avg: SkipTraceRecordAvgAggregateOutputType | null
    _sum: SkipTraceRecordSumAggregateOutputType | null
    _min: SkipTraceRecordMinAggregateOutputType | null
    _max: SkipTraceRecordMaxAggregateOutputType | null
  }

  export type SkipTraceRecordAvgAggregateOutputType = {
    cost: number | null
    confidence: number | null
  }

  export type SkipTraceRecordSumAggregateOutputType = {
    cost: number | null
    confidence: number | null
  }

  export type SkipTraceRecordMinAggregateOutputType = {
    id: string | null
    provider: string | null
    status: string | null
    requestData: string | null
    responseData: string | null
    cost: number | null
    confidence: number | null
    createdAt: Date | null
    completedAt: Date | null
    leadId: string | null
  }

  export type SkipTraceRecordMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    status: string | null
    requestData: string | null
    responseData: string | null
    cost: number | null
    confidence: number | null
    createdAt: Date | null
    completedAt: Date | null
    leadId: string | null
  }

  export type SkipTraceRecordCountAggregateOutputType = {
    id: number
    provider: number
    status: number
    requestData: number
    responseData: number
    cost: number
    confidence: number
    createdAt: number
    completedAt: number
    leadId: number
    _all: number
  }


  export type SkipTraceRecordAvgAggregateInputType = {
    cost?: true
    confidence?: true
  }

  export type SkipTraceRecordSumAggregateInputType = {
    cost?: true
    confidence?: true
  }

  export type SkipTraceRecordMinAggregateInputType = {
    id?: true
    provider?: true
    status?: true
    requestData?: true
    responseData?: true
    cost?: true
    confidence?: true
    createdAt?: true
    completedAt?: true
    leadId?: true
  }

  export type SkipTraceRecordMaxAggregateInputType = {
    id?: true
    provider?: true
    status?: true
    requestData?: true
    responseData?: true
    cost?: true
    confidence?: true
    createdAt?: true
    completedAt?: true
    leadId?: true
  }

  export type SkipTraceRecordCountAggregateInputType = {
    id?: true
    provider?: true
    status?: true
    requestData?: true
    responseData?: true
    cost?: true
    confidence?: true
    createdAt?: true
    completedAt?: true
    leadId?: true
    _all?: true
  }

  export type SkipTraceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkipTraceRecord to aggregate.
     */
    where?: SkipTraceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkipTraceRecords to fetch.
     */
    orderBy?: SkipTraceRecordOrderByWithRelationInput | SkipTraceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkipTraceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkipTraceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkipTraceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkipTraceRecords
    **/
    _count?: true | SkipTraceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkipTraceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkipTraceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkipTraceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkipTraceRecordMaxAggregateInputType
  }

  export type GetSkipTraceRecordAggregateType<T extends SkipTraceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSkipTraceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkipTraceRecord[P]>
      : GetScalarType<T[P], AggregateSkipTraceRecord[P]>
  }




  export type SkipTraceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkipTraceRecordWhereInput
    orderBy?: SkipTraceRecordOrderByWithAggregationInput | SkipTraceRecordOrderByWithAggregationInput[]
    by: SkipTraceRecordScalarFieldEnum[] | SkipTraceRecordScalarFieldEnum
    having?: SkipTraceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkipTraceRecordCountAggregateInputType | true
    _avg?: SkipTraceRecordAvgAggregateInputType
    _sum?: SkipTraceRecordSumAggregateInputType
    _min?: SkipTraceRecordMinAggregateInputType
    _max?: SkipTraceRecordMaxAggregateInputType
  }

  export type SkipTraceRecordGroupByOutputType = {
    id: string
    provider: string
    status: string
    requestData: string
    responseData: string | null
    cost: number | null
    confidence: number | null
    createdAt: Date
    completedAt: Date | null
    leadId: string
    _count: SkipTraceRecordCountAggregateOutputType | null
    _avg: SkipTraceRecordAvgAggregateOutputType | null
    _sum: SkipTraceRecordSumAggregateOutputType | null
    _min: SkipTraceRecordMinAggregateOutputType | null
    _max: SkipTraceRecordMaxAggregateOutputType | null
  }

  type GetSkipTraceRecordGroupByPayload<T extends SkipTraceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkipTraceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkipTraceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkipTraceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SkipTraceRecordGroupByOutputType[P]>
        }
      >
    >


  export type SkipTraceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    cost?: boolean
    confidence?: boolean
    createdAt?: boolean
    completedAt?: boolean
    leadId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skipTraceRecord"]>

  export type SkipTraceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    cost?: boolean
    confidence?: boolean
    createdAt?: boolean
    completedAt?: boolean
    leadId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skipTraceRecord"]>

  export type SkipTraceRecordSelectScalar = {
    id?: boolean
    provider?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    cost?: boolean
    confidence?: boolean
    createdAt?: boolean
    completedAt?: boolean
    leadId?: boolean
  }

  export type SkipTraceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type SkipTraceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $SkipTraceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkipTraceRecord"
    objects: {
      lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      status: string
      requestData: string
      responseData: string | null
      cost: number | null
      confidence: number | null
      createdAt: Date
      completedAt: Date | null
      leadId: string
    }, ExtArgs["result"]["skipTraceRecord"]>
    composites: {}
  }

  type SkipTraceRecordGetPayload<S extends boolean | null | undefined | SkipTraceRecordDefaultArgs> = $Result.GetResult<Prisma.$SkipTraceRecordPayload, S>

  type SkipTraceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkipTraceRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkipTraceRecordCountAggregateInputType | true
    }

  export interface SkipTraceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkipTraceRecord'], meta: { name: 'SkipTraceRecord' } }
    /**
     * Find zero or one SkipTraceRecord that matches the filter.
     * @param {SkipTraceRecordFindUniqueArgs} args - Arguments to find a SkipTraceRecord
     * @example
     * // Get one SkipTraceRecord
     * const skipTraceRecord = await prisma.skipTraceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkipTraceRecordFindUniqueArgs>(args: SelectSubset<T, SkipTraceRecordFindUniqueArgs<ExtArgs>>): Prisma__SkipTraceRecordClient<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SkipTraceRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkipTraceRecordFindUniqueOrThrowArgs} args - Arguments to find a SkipTraceRecord
     * @example
     * // Get one SkipTraceRecord
     * const skipTraceRecord = await prisma.skipTraceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkipTraceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, SkipTraceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkipTraceRecordClient<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SkipTraceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkipTraceRecordFindFirstArgs} args - Arguments to find a SkipTraceRecord
     * @example
     * // Get one SkipTraceRecord
     * const skipTraceRecord = await prisma.skipTraceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkipTraceRecordFindFirstArgs>(args?: SelectSubset<T, SkipTraceRecordFindFirstArgs<ExtArgs>>): Prisma__SkipTraceRecordClient<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SkipTraceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkipTraceRecordFindFirstOrThrowArgs} args - Arguments to find a SkipTraceRecord
     * @example
     * // Get one SkipTraceRecord
     * const skipTraceRecord = await prisma.skipTraceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkipTraceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, SkipTraceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkipTraceRecordClient<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SkipTraceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkipTraceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkipTraceRecords
     * const skipTraceRecords = await prisma.skipTraceRecord.findMany()
     * 
     * // Get first 10 SkipTraceRecords
     * const skipTraceRecords = await prisma.skipTraceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skipTraceRecordWithIdOnly = await prisma.skipTraceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkipTraceRecordFindManyArgs>(args?: SelectSubset<T, SkipTraceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SkipTraceRecord.
     * @param {SkipTraceRecordCreateArgs} args - Arguments to create a SkipTraceRecord.
     * @example
     * // Create one SkipTraceRecord
     * const SkipTraceRecord = await prisma.skipTraceRecord.create({
     *   data: {
     *     // ... data to create a SkipTraceRecord
     *   }
     * })
     * 
     */
    create<T extends SkipTraceRecordCreateArgs>(args: SelectSubset<T, SkipTraceRecordCreateArgs<ExtArgs>>): Prisma__SkipTraceRecordClient<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SkipTraceRecords.
     * @param {SkipTraceRecordCreateManyArgs} args - Arguments to create many SkipTraceRecords.
     * @example
     * // Create many SkipTraceRecords
     * const skipTraceRecord = await prisma.skipTraceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkipTraceRecordCreateManyArgs>(args?: SelectSubset<T, SkipTraceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkipTraceRecords and returns the data saved in the database.
     * @param {SkipTraceRecordCreateManyAndReturnArgs} args - Arguments to create many SkipTraceRecords.
     * @example
     * // Create many SkipTraceRecords
     * const skipTraceRecord = await prisma.skipTraceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkipTraceRecords and only return the `id`
     * const skipTraceRecordWithIdOnly = await prisma.skipTraceRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkipTraceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, SkipTraceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SkipTraceRecord.
     * @param {SkipTraceRecordDeleteArgs} args - Arguments to delete one SkipTraceRecord.
     * @example
     * // Delete one SkipTraceRecord
     * const SkipTraceRecord = await prisma.skipTraceRecord.delete({
     *   where: {
     *     // ... filter to delete one SkipTraceRecord
     *   }
     * })
     * 
     */
    delete<T extends SkipTraceRecordDeleteArgs>(args: SelectSubset<T, SkipTraceRecordDeleteArgs<ExtArgs>>): Prisma__SkipTraceRecordClient<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SkipTraceRecord.
     * @param {SkipTraceRecordUpdateArgs} args - Arguments to update one SkipTraceRecord.
     * @example
     * // Update one SkipTraceRecord
     * const skipTraceRecord = await prisma.skipTraceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkipTraceRecordUpdateArgs>(args: SelectSubset<T, SkipTraceRecordUpdateArgs<ExtArgs>>): Prisma__SkipTraceRecordClient<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SkipTraceRecords.
     * @param {SkipTraceRecordDeleteManyArgs} args - Arguments to filter SkipTraceRecords to delete.
     * @example
     * // Delete a few SkipTraceRecords
     * const { count } = await prisma.skipTraceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkipTraceRecordDeleteManyArgs>(args?: SelectSubset<T, SkipTraceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkipTraceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkipTraceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkipTraceRecords
     * const skipTraceRecord = await prisma.skipTraceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkipTraceRecordUpdateManyArgs>(args: SelectSubset<T, SkipTraceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkipTraceRecord.
     * @param {SkipTraceRecordUpsertArgs} args - Arguments to update or create a SkipTraceRecord.
     * @example
     * // Update or create a SkipTraceRecord
     * const skipTraceRecord = await prisma.skipTraceRecord.upsert({
     *   create: {
     *     // ... data to create a SkipTraceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkipTraceRecord we want to update
     *   }
     * })
     */
    upsert<T extends SkipTraceRecordUpsertArgs>(args: SelectSubset<T, SkipTraceRecordUpsertArgs<ExtArgs>>): Prisma__SkipTraceRecordClient<$Result.GetResult<Prisma.$SkipTraceRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SkipTraceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkipTraceRecordCountArgs} args - Arguments to filter SkipTraceRecords to count.
     * @example
     * // Count the number of SkipTraceRecords
     * const count = await prisma.skipTraceRecord.count({
     *   where: {
     *     // ... the filter for the SkipTraceRecords we want to count
     *   }
     * })
    **/
    count<T extends SkipTraceRecordCountArgs>(
      args?: Subset<T, SkipTraceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkipTraceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkipTraceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkipTraceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkipTraceRecordAggregateArgs>(args: Subset<T, SkipTraceRecordAggregateArgs>): Prisma.PrismaPromise<GetSkipTraceRecordAggregateType<T>>

    /**
     * Group by SkipTraceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkipTraceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkipTraceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkipTraceRecordGroupByArgs['orderBy'] }
        : { orderBy?: SkipTraceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkipTraceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkipTraceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkipTraceRecord model
   */
  readonly fields: SkipTraceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkipTraceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkipTraceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkipTraceRecord model
   */ 
  interface SkipTraceRecordFieldRefs {
    readonly id: FieldRef<"SkipTraceRecord", 'String'>
    readonly provider: FieldRef<"SkipTraceRecord", 'String'>
    readonly status: FieldRef<"SkipTraceRecord", 'String'>
    readonly requestData: FieldRef<"SkipTraceRecord", 'String'>
    readonly responseData: FieldRef<"SkipTraceRecord", 'String'>
    readonly cost: FieldRef<"SkipTraceRecord", 'Float'>
    readonly confidence: FieldRef<"SkipTraceRecord", 'Float'>
    readonly createdAt: FieldRef<"SkipTraceRecord", 'DateTime'>
    readonly completedAt: FieldRef<"SkipTraceRecord", 'DateTime'>
    readonly leadId: FieldRef<"SkipTraceRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SkipTraceRecord findUnique
   */
  export type SkipTraceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SkipTraceRecord to fetch.
     */
    where: SkipTraceRecordWhereUniqueInput
  }

  /**
   * SkipTraceRecord findUniqueOrThrow
   */
  export type SkipTraceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SkipTraceRecord to fetch.
     */
    where: SkipTraceRecordWhereUniqueInput
  }

  /**
   * SkipTraceRecord findFirst
   */
  export type SkipTraceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SkipTraceRecord to fetch.
     */
    where?: SkipTraceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkipTraceRecords to fetch.
     */
    orderBy?: SkipTraceRecordOrderByWithRelationInput | SkipTraceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkipTraceRecords.
     */
    cursor?: SkipTraceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkipTraceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkipTraceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkipTraceRecords.
     */
    distinct?: SkipTraceRecordScalarFieldEnum | SkipTraceRecordScalarFieldEnum[]
  }

  /**
   * SkipTraceRecord findFirstOrThrow
   */
  export type SkipTraceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SkipTraceRecord to fetch.
     */
    where?: SkipTraceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkipTraceRecords to fetch.
     */
    orderBy?: SkipTraceRecordOrderByWithRelationInput | SkipTraceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkipTraceRecords.
     */
    cursor?: SkipTraceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkipTraceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkipTraceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkipTraceRecords.
     */
    distinct?: SkipTraceRecordScalarFieldEnum | SkipTraceRecordScalarFieldEnum[]
  }

  /**
   * SkipTraceRecord findMany
   */
  export type SkipTraceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SkipTraceRecords to fetch.
     */
    where?: SkipTraceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkipTraceRecords to fetch.
     */
    orderBy?: SkipTraceRecordOrderByWithRelationInput | SkipTraceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkipTraceRecords.
     */
    cursor?: SkipTraceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkipTraceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkipTraceRecords.
     */
    skip?: number
    distinct?: SkipTraceRecordScalarFieldEnum | SkipTraceRecordScalarFieldEnum[]
  }

  /**
   * SkipTraceRecord create
   */
  export type SkipTraceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SkipTraceRecord.
     */
    data: XOR<SkipTraceRecordCreateInput, SkipTraceRecordUncheckedCreateInput>
  }

  /**
   * SkipTraceRecord createMany
   */
  export type SkipTraceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkipTraceRecords.
     */
    data: SkipTraceRecordCreateManyInput | SkipTraceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkipTraceRecord createManyAndReturn
   */
  export type SkipTraceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SkipTraceRecords.
     */
    data: SkipTraceRecordCreateManyInput | SkipTraceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkipTraceRecord update
   */
  export type SkipTraceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SkipTraceRecord.
     */
    data: XOR<SkipTraceRecordUpdateInput, SkipTraceRecordUncheckedUpdateInput>
    /**
     * Choose, which SkipTraceRecord to update.
     */
    where: SkipTraceRecordWhereUniqueInput
  }

  /**
   * SkipTraceRecord updateMany
   */
  export type SkipTraceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkipTraceRecords.
     */
    data: XOR<SkipTraceRecordUpdateManyMutationInput, SkipTraceRecordUncheckedUpdateManyInput>
    /**
     * Filter which SkipTraceRecords to update
     */
    where?: SkipTraceRecordWhereInput
  }

  /**
   * SkipTraceRecord upsert
   */
  export type SkipTraceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SkipTraceRecord to update in case it exists.
     */
    where: SkipTraceRecordWhereUniqueInput
    /**
     * In case the SkipTraceRecord found by the `where` argument doesn't exist, create a new SkipTraceRecord with this data.
     */
    create: XOR<SkipTraceRecordCreateInput, SkipTraceRecordUncheckedCreateInput>
    /**
     * In case the SkipTraceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkipTraceRecordUpdateInput, SkipTraceRecordUncheckedUpdateInput>
  }

  /**
   * SkipTraceRecord delete
   */
  export type SkipTraceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
    /**
     * Filter which SkipTraceRecord to delete.
     */
    where: SkipTraceRecordWhereUniqueInput
  }

  /**
   * SkipTraceRecord deleteMany
   */
  export type SkipTraceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkipTraceRecords to delete
     */
    where?: SkipTraceRecordWhereInput
  }

  /**
   * SkipTraceRecord without action
   */
  export type SkipTraceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkipTraceRecord
     */
    select?: SkipTraceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkipTraceRecordInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    targetCount: number | null
    sent: number | null
    delivered: number | null
    opened: number | null
    clicked: number | null
    replied: number | null
  }

  export type CampaignSumAggregateOutputType = {
    targetCount: number | null
    sent: number | null
    delivered: number | null
    opened: number | null
    clicked: number | null
    replied: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    subject: string | null
    message: string | null
    script: string | null
    filters: string | null
    targetCount: number | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    sent: number | null
    delivered: number | null
    opened: number | null
    clicked: number | null
    replied: number | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    subject: string | null
    message: string | null
    script: string | null
    filters: string | null
    targetCount: number | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    sent: number | null
    delivered: number | null
    opened: number | null
    clicked: number | null
    replied: number | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    subject: number
    message: number
    script: number
    filters: number
    targetCount: number
    scheduledAt: number
    startedAt: number
    completedAt: number
    sent: number
    delivered: number
    opened: number
    clicked: number
    replied: number
    createdAt: number
    updatedAt: number
    organizationId: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    targetCount?: true
    sent?: true
    delivered?: true
    opened?: true
    clicked?: true
    replied?: true
  }

  export type CampaignSumAggregateInputType = {
    targetCount?: true
    sent?: true
    delivered?: true
    opened?: true
    clicked?: true
    replied?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    message?: true
    script?: true
    filters?: true
    targetCount?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    sent?: true
    delivered?: true
    opened?: true
    clicked?: true
    replied?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    message?: true
    script?: true
    filters?: true
    targetCount?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    sent?: true
    delivered?: true
    opened?: true
    clicked?: true
    replied?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    message?: true
    script?: true
    filters?: true
    targetCount?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    sent?: true
    delivered?: true
    opened?: true
    clicked?: true
    replied?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    type: string
    status: string
    subject: string | null
    message: string
    script: string | null
    filters: string
    targetCount: number
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    sent: number
    delivered: number
    opened: number
    clicked: number
    replied: number
    createdAt: Date
    updatedAt: Date
    organizationId: string
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    message?: boolean
    script?: boolean
    filters?: boolean
    targetCount?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    sent?: boolean
    delivered?: boolean
    opened?: boolean
    clicked?: boolean
    replied?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    campaignLogs?: boolean | Campaign$campaignLogsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    message?: boolean
    script?: boolean
    filters?: boolean
    targetCount?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    sent?: boolean
    delivered?: boolean
    opened?: boolean
    clicked?: boolean
    replied?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    message?: boolean
    script?: boolean
    filters?: boolean
    targetCount?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    sent?: boolean
    delivered?: boolean
    opened?: boolean
    clicked?: boolean
    replied?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    campaignLogs?: boolean | Campaign$campaignLogsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      campaignLogs: Prisma.$CampaignLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      status: string
      subject: string | null
      message: string
      script: string | null
      filters: string
      targetCount: number
      scheduledAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      sent: number
      delivered: number
      opened: number
      clicked: number
      replied: number
      createdAt: Date
      updatedAt: Date
      organizationId: string
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaignLogs<T extends Campaign$campaignLogsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$campaignLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly subject: FieldRef<"Campaign", 'String'>
    readonly message: FieldRef<"Campaign", 'String'>
    readonly script: FieldRef<"Campaign", 'String'>
    readonly filters: FieldRef<"Campaign", 'String'>
    readonly targetCount: FieldRef<"Campaign", 'Int'>
    readonly scheduledAt: FieldRef<"Campaign", 'DateTime'>
    readonly startedAt: FieldRef<"Campaign", 'DateTime'>
    readonly completedAt: FieldRef<"Campaign", 'DateTime'>
    readonly sent: FieldRef<"Campaign", 'Int'>
    readonly delivered: FieldRef<"Campaign", 'Int'>
    readonly opened: FieldRef<"Campaign", 'Int'>
    readonly clicked: FieldRef<"Campaign", 'Int'>
    readonly replied: FieldRef<"Campaign", 'Int'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly organizationId: FieldRef<"Campaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.campaignLogs
   */
  export type Campaign$campaignLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    where?: CampaignLogWhereInput
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    cursor?: CampaignLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignLog
   */

  export type AggregateCampaignLog = {
    _count: CampaignLogCountAggregateOutputType | null
    _min: CampaignLogMinAggregateOutputType | null
    _max: CampaignLogMaxAggregateOutputType | null
  }

  export type CampaignLogMinAggregateOutputType = {
    id: string | null
    status: string | null
    response: string | null
    errorMessage: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    openedAt: Date | null
    repliedAt: Date | null
    campaignId: string | null
    leadId: string | null
    userId: string | null
  }

  export type CampaignLogMaxAggregateOutputType = {
    id: string | null
    status: string | null
    response: string | null
    errorMessage: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    openedAt: Date | null
    repliedAt: Date | null
    campaignId: string | null
    leadId: string | null
    userId: string | null
  }

  export type CampaignLogCountAggregateOutputType = {
    id: number
    status: number
    response: number
    errorMessage: number
    sentAt: number
    deliveredAt: number
    openedAt: number
    repliedAt: number
    campaignId: number
    leadId: number
    userId: number
    _all: number
  }


  export type CampaignLogMinAggregateInputType = {
    id?: true
    status?: true
    response?: true
    errorMessage?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    repliedAt?: true
    campaignId?: true
    leadId?: true
    userId?: true
  }

  export type CampaignLogMaxAggregateInputType = {
    id?: true
    status?: true
    response?: true
    errorMessage?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    repliedAt?: true
    campaignId?: true
    leadId?: true
    userId?: true
  }

  export type CampaignLogCountAggregateInputType = {
    id?: true
    status?: true
    response?: true
    errorMessage?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    repliedAt?: true
    campaignId?: true
    leadId?: true
    userId?: true
    _all?: true
  }

  export type CampaignLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLog to aggregate.
     */
    where?: CampaignLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLogs to fetch.
     */
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignLogs
    **/
    _count?: true | CampaignLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignLogMaxAggregateInputType
  }

  export type GetCampaignLogAggregateType<T extends CampaignLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignLog[P]>
      : GetScalarType<T[P], AggregateCampaignLog[P]>
  }




  export type CampaignLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLogWhereInput
    orderBy?: CampaignLogOrderByWithAggregationInput | CampaignLogOrderByWithAggregationInput[]
    by: CampaignLogScalarFieldEnum[] | CampaignLogScalarFieldEnum
    having?: CampaignLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignLogCountAggregateInputType | true
    _min?: CampaignLogMinAggregateInputType
    _max?: CampaignLogMaxAggregateInputType
  }

  export type CampaignLogGroupByOutputType = {
    id: string
    status: string
    response: string | null
    errorMessage: string | null
    sentAt: Date
    deliveredAt: Date | null
    openedAt: Date | null
    repliedAt: Date | null
    campaignId: string
    leadId: string
    userId: string | null
    _count: CampaignLogCountAggregateOutputType | null
    _min: CampaignLogMinAggregateOutputType | null
    _max: CampaignLogMaxAggregateOutputType | null
  }

  type GetCampaignLogGroupByPayload<T extends CampaignLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignLogGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignLogGroupByOutputType[P]>
        }
      >
    >


  export type CampaignLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    response?: boolean
    errorMessage?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    repliedAt?: boolean
    campaignId?: boolean
    leadId?: boolean
    userId?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    user?: boolean | CampaignLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLog"]>

  export type CampaignLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    response?: boolean
    errorMessage?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    repliedAt?: boolean
    campaignId?: boolean
    leadId?: boolean
    userId?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    user?: boolean | CampaignLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLog"]>

  export type CampaignLogSelectScalar = {
    id?: boolean
    status?: boolean
    response?: boolean
    errorMessage?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    repliedAt?: boolean
    campaignId?: boolean
    leadId?: boolean
    userId?: boolean
  }

  export type CampaignLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    user?: boolean | CampaignLog$userArgs<ExtArgs>
  }
  export type CampaignLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    user?: boolean | CampaignLog$userArgs<ExtArgs>
  }

  export type $CampaignLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignLog"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      response: string | null
      errorMessage: string | null
      sentAt: Date
      deliveredAt: Date | null
      openedAt: Date | null
      repliedAt: Date | null
      campaignId: string
      leadId: string
      userId: string | null
    }, ExtArgs["result"]["campaignLog"]>
    composites: {}
  }

  type CampaignLogGetPayload<S extends boolean | null | undefined | CampaignLogDefaultArgs> = $Result.GetResult<Prisma.$CampaignLogPayload, S>

  type CampaignLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignLogCountAggregateInputType | true
    }

  export interface CampaignLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignLog'], meta: { name: 'CampaignLog' } }
    /**
     * Find zero or one CampaignLog that matches the filter.
     * @param {CampaignLogFindUniqueArgs} args - Arguments to find a CampaignLog
     * @example
     * // Get one CampaignLog
     * const campaignLog = await prisma.campaignLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignLogFindUniqueArgs>(args: SelectSubset<T, CampaignLogFindUniqueArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignLogFindUniqueOrThrowArgs} args - Arguments to find a CampaignLog
     * @example
     * // Get one CampaignLog
     * const campaignLog = await prisma.campaignLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogFindFirstArgs} args - Arguments to find a CampaignLog
     * @example
     * // Get one CampaignLog
     * const campaignLog = await prisma.campaignLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignLogFindFirstArgs>(args?: SelectSubset<T, CampaignLogFindFirstArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogFindFirstOrThrowArgs} args - Arguments to find a CampaignLog
     * @example
     * // Get one CampaignLog
     * const campaignLog = await prisma.campaignLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignLogs
     * const campaignLogs = await prisma.campaignLog.findMany()
     * 
     * // Get first 10 CampaignLogs
     * const campaignLogs = await prisma.campaignLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignLogWithIdOnly = await prisma.campaignLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignLogFindManyArgs>(args?: SelectSubset<T, CampaignLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignLog.
     * @param {CampaignLogCreateArgs} args - Arguments to create a CampaignLog.
     * @example
     * // Create one CampaignLog
     * const CampaignLog = await prisma.campaignLog.create({
     *   data: {
     *     // ... data to create a CampaignLog
     *   }
     * })
     * 
     */
    create<T extends CampaignLogCreateArgs>(args: SelectSubset<T, CampaignLogCreateArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignLogs.
     * @param {CampaignLogCreateManyArgs} args - Arguments to create many CampaignLogs.
     * @example
     * // Create many CampaignLogs
     * const campaignLog = await prisma.campaignLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignLogCreateManyArgs>(args?: SelectSubset<T, CampaignLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignLogs and returns the data saved in the database.
     * @param {CampaignLogCreateManyAndReturnArgs} args - Arguments to create many CampaignLogs.
     * @example
     * // Create many CampaignLogs
     * const campaignLog = await prisma.campaignLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignLogs and only return the `id`
     * const campaignLogWithIdOnly = await prisma.campaignLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignLog.
     * @param {CampaignLogDeleteArgs} args - Arguments to delete one CampaignLog.
     * @example
     * // Delete one CampaignLog
     * const CampaignLog = await prisma.campaignLog.delete({
     *   where: {
     *     // ... filter to delete one CampaignLog
     *   }
     * })
     * 
     */
    delete<T extends CampaignLogDeleteArgs>(args: SelectSubset<T, CampaignLogDeleteArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignLog.
     * @param {CampaignLogUpdateArgs} args - Arguments to update one CampaignLog.
     * @example
     * // Update one CampaignLog
     * const campaignLog = await prisma.campaignLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignLogUpdateArgs>(args: SelectSubset<T, CampaignLogUpdateArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignLogs.
     * @param {CampaignLogDeleteManyArgs} args - Arguments to filter CampaignLogs to delete.
     * @example
     * // Delete a few CampaignLogs
     * const { count } = await prisma.campaignLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignLogDeleteManyArgs>(args?: SelectSubset<T, CampaignLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignLogs
     * const campaignLog = await prisma.campaignLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignLogUpdateManyArgs>(args: SelectSubset<T, CampaignLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignLog.
     * @param {CampaignLogUpsertArgs} args - Arguments to update or create a CampaignLog.
     * @example
     * // Update or create a CampaignLog
     * const campaignLog = await prisma.campaignLog.upsert({
     *   create: {
     *     // ... data to create a CampaignLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignLog we want to update
     *   }
     * })
     */
    upsert<T extends CampaignLogUpsertArgs>(args: SelectSubset<T, CampaignLogUpsertArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogCountArgs} args - Arguments to filter CampaignLogs to count.
     * @example
     * // Count the number of CampaignLogs
     * const count = await prisma.campaignLog.count({
     *   where: {
     *     // ... the filter for the CampaignLogs we want to count
     *   }
     * })
    **/
    count<T extends CampaignLogCountArgs>(
      args?: Subset<T, CampaignLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignLogAggregateArgs>(args: Subset<T, CampaignLogAggregateArgs>): Prisma.PrismaPromise<GetCampaignLogAggregateType<T>>

    /**
     * Group by CampaignLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignLogGroupByArgs['orderBy'] }
        : { orderBy?: CampaignLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignLog model
   */
  readonly fields: CampaignLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends CampaignLog$userArgs<ExtArgs> = {}>(args?: Subset<T, CampaignLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignLog model
   */ 
  interface CampaignLogFieldRefs {
    readonly id: FieldRef<"CampaignLog", 'String'>
    readonly status: FieldRef<"CampaignLog", 'String'>
    readonly response: FieldRef<"CampaignLog", 'String'>
    readonly errorMessage: FieldRef<"CampaignLog", 'String'>
    readonly sentAt: FieldRef<"CampaignLog", 'DateTime'>
    readonly deliveredAt: FieldRef<"CampaignLog", 'DateTime'>
    readonly openedAt: FieldRef<"CampaignLog", 'DateTime'>
    readonly repliedAt: FieldRef<"CampaignLog", 'DateTime'>
    readonly campaignId: FieldRef<"CampaignLog", 'String'>
    readonly leadId: FieldRef<"CampaignLog", 'String'>
    readonly userId: FieldRef<"CampaignLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CampaignLog findUnique
   */
  export type CampaignLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLog to fetch.
     */
    where: CampaignLogWhereUniqueInput
  }

  /**
   * CampaignLog findUniqueOrThrow
   */
  export type CampaignLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLog to fetch.
     */
    where: CampaignLogWhereUniqueInput
  }

  /**
   * CampaignLog findFirst
   */
  export type CampaignLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLog to fetch.
     */
    where?: CampaignLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLogs to fetch.
     */
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLogs.
     */
    cursor?: CampaignLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLogs.
     */
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * CampaignLog findFirstOrThrow
   */
  export type CampaignLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLog to fetch.
     */
    where?: CampaignLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLogs to fetch.
     */
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLogs.
     */
    cursor?: CampaignLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLogs.
     */
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * CampaignLog findMany
   */
  export type CampaignLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLogs to fetch.
     */
    where?: CampaignLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLogs to fetch.
     */
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignLogs.
     */
    cursor?: CampaignLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLogs.
     */
    skip?: number
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * CampaignLog create
   */
  export type CampaignLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignLog.
     */
    data: XOR<CampaignLogCreateInput, CampaignLogUncheckedCreateInput>
  }

  /**
   * CampaignLog createMany
   */
  export type CampaignLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignLogs.
     */
    data: CampaignLogCreateManyInput | CampaignLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignLog createManyAndReturn
   */
  export type CampaignLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignLogs.
     */
    data: CampaignLogCreateManyInput | CampaignLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignLog update
   */
  export type CampaignLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignLog.
     */
    data: XOR<CampaignLogUpdateInput, CampaignLogUncheckedUpdateInput>
    /**
     * Choose, which CampaignLog to update.
     */
    where: CampaignLogWhereUniqueInput
  }

  /**
   * CampaignLog updateMany
   */
  export type CampaignLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignLogs.
     */
    data: XOR<CampaignLogUpdateManyMutationInput, CampaignLogUncheckedUpdateManyInput>
    /**
     * Filter which CampaignLogs to update
     */
    where?: CampaignLogWhereInput
  }

  /**
   * CampaignLog upsert
   */
  export type CampaignLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignLog to update in case it exists.
     */
    where: CampaignLogWhereUniqueInput
    /**
     * In case the CampaignLog found by the `where` argument doesn't exist, create a new CampaignLog with this data.
     */
    create: XOR<CampaignLogCreateInput, CampaignLogUncheckedCreateInput>
    /**
     * In case the CampaignLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignLogUpdateInput, CampaignLogUncheckedUpdateInput>
  }

  /**
   * CampaignLog delete
   */
  export type CampaignLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter which CampaignLog to delete.
     */
    where: CampaignLogWhereUniqueInput
  }

  /**
   * CampaignLog deleteMany
   */
  export type CampaignLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLogs to delete
     */
    where?: CampaignLogWhereInput
  }

  /**
   * CampaignLog.user
   */
  export type CampaignLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CampaignLog without action
   */
  export type CampaignLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
  }


  /**
   * Model CallLog
   */

  export type AggregateCallLog = {
    _count: CallLogCountAggregateOutputType | null
    _avg: CallLogAvgAggregateOutputType | null
    _sum: CallLogSumAggregateOutputType | null
    _min: CallLogMinAggregateOutputType | null
    _max: CallLogMaxAggregateOutputType | null
  }

  export type CallLogAvgAggregateOutputType = {
    duration: number | null
    motivationScore: number | null
  }

  export type CallLogSumAggregateOutputType = {
    duration: number | null
    motivationScore: number | null
  }

  export type CallLogMinAggregateOutputType = {
    id: string | null
    direction: string | null
    status: string | null
    duration: number | null
    transcript: string | null
    recording: string | null
    fromNumber: string | null
    toNumber: string | null
    twilioCallSid: string | null
    sentiment: string | null
    aiSummary: string | null
    motivationScore: number | null
    outcome: string | null
    followUpDate: Date | null
    callStartedAt: Date | null
    callEndedAt: Date | null
    createdAt: Date | null
    leadId: string | null
    organizationId: string | null
    createdById: string | null
  }

  export type CallLogMaxAggregateOutputType = {
    id: string | null
    direction: string | null
    status: string | null
    duration: number | null
    transcript: string | null
    recording: string | null
    fromNumber: string | null
    toNumber: string | null
    twilioCallSid: string | null
    sentiment: string | null
    aiSummary: string | null
    motivationScore: number | null
    outcome: string | null
    followUpDate: Date | null
    callStartedAt: Date | null
    callEndedAt: Date | null
    createdAt: Date | null
    leadId: string | null
    organizationId: string | null
    createdById: string | null
  }

  export type CallLogCountAggregateOutputType = {
    id: number
    direction: number
    status: number
    duration: number
    transcript: number
    recording: number
    fromNumber: number
    toNumber: number
    twilioCallSid: number
    sentiment: number
    aiSummary: number
    motivationScore: number
    outcome: number
    followUpDate: number
    callStartedAt: number
    callEndedAt: number
    createdAt: number
    leadId: number
    organizationId: number
    createdById: number
    _all: number
  }


  export type CallLogAvgAggregateInputType = {
    duration?: true
    motivationScore?: true
  }

  export type CallLogSumAggregateInputType = {
    duration?: true
    motivationScore?: true
  }

  export type CallLogMinAggregateInputType = {
    id?: true
    direction?: true
    status?: true
    duration?: true
    transcript?: true
    recording?: true
    fromNumber?: true
    toNumber?: true
    twilioCallSid?: true
    sentiment?: true
    aiSummary?: true
    motivationScore?: true
    outcome?: true
    followUpDate?: true
    callStartedAt?: true
    callEndedAt?: true
    createdAt?: true
    leadId?: true
    organizationId?: true
    createdById?: true
  }

  export type CallLogMaxAggregateInputType = {
    id?: true
    direction?: true
    status?: true
    duration?: true
    transcript?: true
    recording?: true
    fromNumber?: true
    toNumber?: true
    twilioCallSid?: true
    sentiment?: true
    aiSummary?: true
    motivationScore?: true
    outcome?: true
    followUpDate?: true
    callStartedAt?: true
    callEndedAt?: true
    createdAt?: true
    leadId?: true
    organizationId?: true
    createdById?: true
  }

  export type CallLogCountAggregateInputType = {
    id?: true
    direction?: true
    status?: true
    duration?: true
    transcript?: true
    recording?: true
    fromNumber?: true
    toNumber?: true
    twilioCallSid?: true
    sentiment?: true
    aiSummary?: true
    motivationScore?: true
    outcome?: true
    followUpDate?: true
    callStartedAt?: true
    callEndedAt?: true
    createdAt?: true
    leadId?: true
    organizationId?: true
    createdById?: true
    _all?: true
  }

  export type CallLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallLog to aggregate.
     */
    where?: CallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallLogs to fetch.
     */
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallLogs
    **/
    _count?: true | CallLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallLogMaxAggregateInputType
  }

  export type GetCallLogAggregateType<T extends CallLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCallLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallLog[P]>
      : GetScalarType<T[P], AggregateCallLog[P]>
  }




  export type CallLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallLogWhereInput
    orderBy?: CallLogOrderByWithAggregationInput | CallLogOrderByWithAggregationInput[]
    by: CallLogScalarFieldEnum[] | CallLogScalarFieldEnum
    having?: CallLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallLogCountAggregateInputType | true
    _avg?: CallLogAvgAggregateInputType
    _sum?: CallLogSumAggregateInputType
    _min?: CallLogMinAggregateInputType
    _max?: CallLogMaxAggregateInputType
  }

  export type CallLogGroupByOutputType = {
    id: string
    direction: string
    status: string
    duration: number | null
    transcript: string | null
    recording: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid: string | null
    sentiment: string | null
    aiSummary: string | null
    motivationScore: number | null
    outcome: string | null
    followUpDate: Date | null
    callStartedAt: Date
    callEndedAt: Date | null
    createdAt: Date
    leadId: string
    organizationId: string
    createdById: string
    _count: CallLogCountAggregateOutputType | null
    _avg: CallLogAvgAggregateOutputType | null
    _sum: CallLogSumAggregateOutputType | null
    _min: CallLogMinAggregateOutputType | null
    _max: CallLogMaxAggregateOutputType | null
  }

  type GetCallLogGroupByPayload<T extends CallLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallLogGroupByOutputType[P]>
            : GetScalarType<T[P], CallLogGroupByOutputType[P]>
        }
      >
    >


  export type CallLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    direction?: boolean
    status?: boolean
    duration?: boolean
    transcript?: boolean
    recording?: boolean
    fromNumber?: boolean
    toNumber?: boolean
    twilioCallSid?: boolean
    sentiment?: boolean
    aiSummary?: boolean
    motivationScore?: boolean
    outcome?: boolean
    followUpDate?: boolean
    callStartedAt?: boolean
    callEndedAt?: boolean
    createdAt?: boolean
    leadId?: boolean
    organizationId?: boolean
    createdById?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callLog"]>

  export type CallLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    direction?: boolean
    status?: boolean
    duration?: boolean
    transcript?: boolean
    recording?: boolean
    fromNumber?: boolean
    toNumber?: boolean
    twilioCallSid?: boolean
    sentiment?: boolean
    aiSummary?: boolean
    motivationScore?: boolean
    outcome?: boolean
    followUpDate?: boolean
    callStartedAt?: boolean
    callEndedAt?: boolean
    createdAt?: boolean
    leadId?: boolean
    organizationId?: boolean
    createdById?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callLog"]>

  export type CallLogSelectScalar = {
    id?: boolean
    direction?: boolean
    status?: boolean
    duration?: boolean
    transcript?: boolean
    recording?: boolean
    fromNumber?: boolean
    toNumber?: boolean
    twilioCallSid?: boolean
    sentiment?: boolean
    aiSummary?: boolean
    motivationScore?: boolean
    outcome?: boolean
    followUpDate?: boolean
    callStartedAt?: boolean
    callEndedAt?: boolean
    createdAt?: boolean
    leadId?: boolean
    organizationId?: boolean
    createdById?: boolean
  }

  export type CallLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CallLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CallLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallLog"
    objects: {
      lead: Prisma.$LeadPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      direction: string
      status: string
      duration: number | null
      transcript: string | null
      recording: string | null
      fromNumber: string
      toNumber: string
      twilioCallSid: string | null
      sentiment: string | null
      aiSummary: string | null
      motivationScore: number | null
      outcome: string | null
      followUpDate: Date | null
      callStartedAt: Date
      callEndedAt: Date | null
      createdAt: Date
      leadId: string
      organizationId: string
      createdById: string
    }, ExtArgs["result"]["callLog"]>
    composites: {}
  }

  type CallLogGetPayload<S extends boolean | null | undefined | CallLogDefaultArgs> = $Result.GetResult<Prisma.$CallLogPayload, S>

  type CallLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CallLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallLogCountAggregateInputType | true
    }

  export interface CallLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallLog'], meta: { name: 'CallLog' } }
    /**
     * Find zero or one CallLog that matches the filter.
     * @param {CallLogFindUniqueArgs} args - Arguments to find a CallLog
     * @example
     * // Get one CallLog
     * const callLog = await prisma.callLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallLogFindUniqueArgs>(args: SelectSubset<T, CallLogFindUniqueArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CallLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CallLogFindUniqueOrThrowArgs} args - Arguments to find a CallLog
     * @example
     * // Get one CallLog
     * const callLog = await prisma.callLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CallLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CallLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogFindFirstArgs} args - Arguments to find a CallLog
     * @example
     * // Get one CallLog
     * const callLog = await prisma.callLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallLogFindFirstArgs>(args?: SelectSubset<T, CallLogFindFirstArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CallLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogFindFirstOrThrowArgs} args - Arguments to find a CallLog
     * @example
     * // Get one CallLog
     * const callLog = await prisma.callLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CallLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CallLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallLogs
     * const callLogs = await prisma.callLog.findMany()
     * 
     * // Get first 10 CallLogs
     * const callLogs = await prisma.callLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callLogWithIdOnly = await prisma.callLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallLogFindManyArgs>(args?: SelectSubset<T, CallLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CallLog.
     * @param {CallLogCreateArgs} args - Arguments to create a CallLog.
     * @example
     * // Create one CallLog
     * const CallLog = await prisma.callLog.create({
     *   data: {
     *     // ... data to create a CallLog
     *   }
     * })
     * 
     */
    create<T extends CallLogCreateArgs>(args: SelectSubset<T, CallLogCreateArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CallLogs.
     * @param {CallLogCreateManyArgs} args - Arguments to create many CallLogs.
     * @example
     * // Create many CallLogs
     * const callLog = await prisma.callLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallLogCreateManyArgs>(args?: SelectSubset<T, CallLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallLogs and returns the data saved in the database.
     * @param {CallLogCreateManyAndReturnArgs} args - Arguments to create many CallLogs.
     * @example
     * // Create many CallLogs
     * const callLog = await prisma.callLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallLogs and only return the `id`
     * const callLogWithIdOnly = await prisma.callLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CallLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CallLog.
     * @param {CallLogDeleteArgs} args - Arguments to delete one CallLog.
     * @example
     * // Delete one CallLog
     * const CallLog = await prisma.callLog.delete({
     *   where: {
     *     // ... filter to delete one CallLog
     *   }
     * })
     * 
     */
    delete<T extends CallLogDeleteArgs>(args: SelectSubset<T, CallLogDeleteArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CallLog.
     * @param {CallLogUpdateArgs} args - Arguments to update one CallLog.
     * @example
     * // Update one CallLog
     * const callLog = await prisma.callLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallLogUpdateArgs>(args: SelectSubset<T, CallLogUpdateArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CallLogs.
     * @param {CallLogDeleteManyArgs} args - Arguments to filter CallLogs to delete.
     * @example
     * // Delete a few CallLogs
     * const { count } = await prisma.callLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallLogDeleteManyArgs>(args?: SelectSubset<T, CallLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallLogs
     * const callLog = await prisma.callLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallLogUpdateManyArgs>(args: SelectSubset<T, CallLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CallLog.
     * @param {CallLogUpsertArgs} args - Arguments to update or create a CallLog.
     * @example
     * // Update or create a CallLog
     * const callLog = await prisma.callLog.upsert({
     *   create: {
     *     // ... data to create a CallLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallLog we want to update
     *   }
     * })
     */
    upsert<T extends CallLogUpsertArgs>(args: SelectSubset<T, CallLogUpsertArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CallLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogCountArgs} args - Arguments to filter CallLogs to count.
     * @example
     * // Count the number of CallLogs
     * const count = await prisma.callLog.count({
     *   where: {
     *     // ... the filter for the CallLogs we want to count
     *   }
     * })
    **/
    count<T extends CallLogCountArgs>(
      args?: Subset<T, CallLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallLogAggregateArgs>(args: Subset<T, CallLogAggregateArgs>): Prisma.PrismaPromise<GetCallLogAggregateType<T>>

    /**
     * Group by CallLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallLogGroupByArgs['orderBy'] }
        : { orderBy?: CallLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallLog model
   */
  readonly fields: CallLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallLog model
   */ 
  interface CallLogFieldRefs {
    readonly id: FieldRef<"CallLog", 'String'>
    readonly direction: FieldRef<"CallLog", 'String'>
    readonly status: FieldRef<"CallLog", 'String'>
    readonly duration: FieldRef<"CallLog", 'Int'>
    readonly transcript: FieldRef<"CallLog", 'String'>
    readonly recording: FieldRef<"CallLog", 'String'>
    readonly fromNumber: FieldRef<"CallLog", 'String'>
    readonly toNumber: FieldRef<"CallLog", 'String'>
    readonly twilioCallSid: FieldRef<"CallLog", 'String'>
    readonly sentiment: FieldRef<"CallLog", 'String'>
    readonly aiSummary: FieldRef<"CallLog", 'String'>
    readonly motivationScore: FieldRef<"CallLog", 'Float'>
    readonly outcome: FieldRef<"CallLog", 'String'>
    readonly followUpDate: FieldRef<"CallLog", 'DateTime'>
    readonly callStartedAt: FieldRef<"CallLog", 'DateTime'>
    readonly callEndedAt: FieldRef<"CallLog", 'DateTime'>
    readonly createdAt: FieldRef<"CallLog", 'DateTime'>
    readonly leadId: FieldRef<"CallLog", 'String'>
    readonly organizationId: FieldRef<"CallLog", 'String'>
    readonly createdById: FieldRef<"CallLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CallLog findUnique
   */
  export type CallLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLog to fetch.
     */
    where: CallLogWhereUniqueInput
  }

  /**
   * CallLog findUniqueOrThrow
   */
  export type CallLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLog to fetch.
     */
    where: CallLogWhereUniqueInput
  }

  /**
   * CallLog findFirst
   */
  export type CallLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLog to fetch.
     */
    where?: CallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallLogs to fetch.
     */
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallLogs.
     */
    cursor?: CallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallLogs.
     */
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * CallLog findFirstOrThrow
   */
  export type CallLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLog to fetch.
     */
    where?: CallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallLogs to fetch.
     */
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallLogs.
     */
    cursor?: CallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallLogs.
     */
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * CallLog findMany
   */
  export type CallLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLogs to fetch.
     */
    where?: CallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallLogs to fetch.
     */
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallLogs.
     */
    cursor?: CallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallLogs.
     */
    skip?: number
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * CallLog create
   */
  export type CallLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CallLog.
     */
    data: XOR<CallLogCreateInput, CallLogUncheckedCreateInput>
  }

  /**
   * CallLog createMany
   */
  export type CallLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallLogs.
     */
    data: CallLogCreateManyInput | CallLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallLog createManyAndReturn
   */
  export type CallLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CallLogs.
     */
    data: CallLogCreateManyInput | CallLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallLog update
   */
  export type CallLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CallLog.
     */
    data: XOR<CallLogUpdateInput, CallLogUncheckedUpdateInput>
    /**
     * Choose, which CallLog to update.
     */
    where: CallLogWhereUniqueInput
  }

  /**
   * CallLog updateMany
   */
  export type CallLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallLogs.
     */
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyInput>
    /**
     * Filter which CallLogs to update
     */
    where?: CallLogWhereInput
  }

  /**
   * CallLog upsert
   */
  export type CallLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CallLog to update in case it exists.
     */
    where: CallLogWhereUniqueInput
    /**
     * In case the CallLog found by the `where` argument doesn't exist, create a new CallLog with this data.
     */
    create: XOR<CallLogCreateInput, CallLogUncheckedCreateInput>
    /**
     * In case the CallLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallLogUpdateInput, CallLogUncheckedUpdateInput>
  }

  /**
   * CallLog delete
   */
  export type CallLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter which CallLog to delete.
     */
    where: CallLogWhereUniqueInput
  }

  /**
   * CallLog deleteMany
   */
  export type CallLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallLogs to delete
     */
    where?: CallLogWhereInput
  }

  /**
   * CallLog without action
   */
  export type CallLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
  }


  /**
   * Model ScrapingJob
   */

  export type AggregateScrapingJob = {
    _count: ScrapingJobCountAggregateOutputType | null
    _avg: ScrapingJobAvgAggregateOutputType | null
    _sum: ScrapingJobSumAggregateOutputType | null
    _min: ScrapingJobMinAggregateOutputType | null
    _max: ScrapingJobMaxAggregateOutputType | null
  }

  export type ScrapingJobAvgAggregateOutputType = {
    recordsFound: number | null
    recordsSaved: number | null
    errorCount: number | null
  }

  export type ScrapingJobSumAggregateOutputType = {
    recordsFound: number | null
    recordsSaved: number | null
    errorCount: number | null
  }

  export type ScrapingJobMinAggregateOutputType = {
    id: string | null
    source: string | null
    status: string | null
    config: string | null
    recordsFound: number | null
    recordsSaved: number | null
    errorCount: number | null
    logs: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type ScrapingJobMaxAggregateOutputType = {
    id: string | null
    source: string | null
    status: string | null
    config: string | null
    recordsFound: number | null
    recordsSaved: number | null
    errorCount: number | null
    logs: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type ScrapingJobCountAggregateOutputType = {
    id: number
    source: number
    status: number
    config: number
    recordsFound: number
    recordsSaved: number
    errorCount: number
    logs: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type ScrapingJobAvgAggregateInputType = {
    recordsFound?: true
    recordsSaved?: true
    errorCount?: true
  }

  export type ScrapingJobSumAggregateInputType = {
    recordsFound?: true
    recordsSaved?: true
    errorCount?: true
  }

  export type ScrapingJobMinAggregateInputType = {
    id?: true
    source?: true
    status?: true
    config?: true
    recordsFound?: true
    recordsSaved?: true
    errorCount?: true
    logs?: true
    startedAt?: true
    completedAt?: true
  }

  export type ScrapingJobMaxAggregateInputType = {
    id?: true
    source?: true
    status?: true
    config?: true
    recordsFound?: true
    recordsSaved?: true
    errorCount?: true
    logs?: true
    startedAt?: true
    completedAt?: true
  }

  export type ScrapingJobCountAggregateInputType = {
    id?: true
    source?: true
    status?: true
    config?: true
    recordsFound?: true
    recordsSaved?: true
    errorCount?: true
    logs?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ScrapingJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScrapingJob to aggregate.
     */
    where?: ScrapingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScrapingJobs to fetch.
     */
    orderBy?: ScrapingJobOrderByWithRelationInput | ScrapingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScrapingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScrapingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScrapingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScrapingJobs
    **/
    _count?: true | ScrapingJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScrapingJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScrapingJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScrapingJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScrapingJobMaxAggregateInputType
  }

  export type GetScrapingJobAggregateType<T extends ScrapingJobAggregateArgs> = {
        [P in keyof T & keyof AggregateScrapingJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScrapingJob[P]>
      : GetScalarType<T[P], AggregateScrapingJob[P]>
  }




  export type ScrapingJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScrapingJobWhereInput
    orderBy?: ScrapingJobOrderByWithAggregationInput | ScrapingJobOrderByWithAggregationInput[]
    by: ScrapingJobScalarFieldEnum[] | ScrapingJobScalarFieldEnum
    having?: ScrapingJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScrapingJobCountAggregateInputType | true
    _avg?: ScrapingJobAvgAggregateInputType
    _sum?: ScrapingJobSumAggregateInputType
    _min?: ScrapingJobMinAggregateInputType
    _max?: ScrapingJobMaxAggregateInputType
  }

  export type ScrapingJobGroupByOutputType = {
    id: string
    source: string
    status: string
    config: string
    recordsFound: number
    recordsSaved: number
    errorCount: number
    logs: string | null
    startedAt: Date
    completedAt: Date | null
    _count: ScrapingJobCountAggregateOutputType | null
    _avg: ScrapingJobAvgAggregateOutputType | null
    _sum: ScrapingJobSumAggregateOutputType | null
    _min: ScrapingJobMinAggregateOutputType | null
    _max: ScrapingJobMaxAggregateOutputType | null
  }

  type GetScrapingJobGroupByPayload<T extends ScrapingJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScrapingJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScrapingJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScrapingJobGroupByOutputType[P]>
            : GetScalarType<T[P], ScrapingJobGroupByOutputType[P]>
        }
      >
    >


  export type ScrapingJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    status?: boolean
    config?: boolean
    recordsFound?: boolean
    recordsSaved?: boolean
    errorCount?: boolean
    logs?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["scrapingJob"]>

  export type ScrapingJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    status?: boolean
    config?: boolean
    recordsFound?: boolean
    recordsSaved?: boolean
    errorCount?: boolean
    logs?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["scrapingJob"]>

  export type ScrapingJobSelectScalar = {
    id?: boolean
    source?: boolean
    status?: boolean
    config?: boolean
    recordsFound?: boolean
    recordsSaved?: boolean
    errorCount?: boolean
    logs?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }


  export type $ScrapingJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScrapingJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: string
      status: string
      config: string
      recordsFound: number
      recordsSaved: number
      errorCount: number
      logs: string | null
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["scrapingJob"]>
    composites: {}
  }

  type ScrapingJobGetPayload<S extends boolean | null | undefined | ScrapingJobDefaultArgs> = $Result.GetResult<Prisma.$ScrapingJobPayload, S>

  type ScrapingJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScrapingJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScrapingJobCountAggregateInputType | true
    }

  export interface ScrapingJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScrapingJob'], meta: { name: 'ScrapingJob' } }
    /**
     * Find zero or one ScrapingJob that matches the filter.
     * @param {ScrapingJobFindUniqueArgs} args - Arguments to find a ScrapingJob
     * @example
     * // Get one ScrapingJob
     * const scrapingJob = await prisma.scrapingJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScrapingJobFindUniqueArgs>(args: SelectSubset<T, ScrapingJobFindUniqueArgs<ExtArgs>>): Prisma__ScrapingJobClient<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScrapingJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScrapingJobFindUniqueOrThrowArgs} args - Arguments to find a ScrapingJob
     * @example
     * // Get one ScrapingJob
     * const scrapingJob = await prisma.scrapingJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScrapingJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ScrapingJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScrapingJobClient<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScrapingJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrapingJobFindFirstArgs} args - Arguments to find a ScrapingJob
     * @example
     * // Get one ScrapingJob
     * const scrapingJob = await prisma.scrapingJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScrapingJobFindFirstArgs>(args?: SelectSubset<T, ScrapingJobFindFirstArgs<ExtArgs>>): Prisma__ScrapingJobClient<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScrapingJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrapingJobFindFirstOrThrowArgs} args - Arguments to find a ScrapingJob
     * @example
     * // Get one ScrapingJob
     * const scrapingJob = await prisma.scrapingJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScrapingJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ScrapingJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScrapingJobClient<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScrapingJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrapingJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScrapingJobs
     * const scrapingJobs = await prisma.scrapingJob.findMany()
     * 
     * // Get first 10 ScrapingJobs
     * const scrapingJobs = await prisma.scrapingJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scrapingJobWithIdOnly = await prisma.scrapingJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScrapingJobFindManyArgs>(args?: SelectSubset<T, ScrapingJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScrapingJob.
     * @param {ScrapingJobCreateArgs} args - Arguments to create a ScrapingJob.
     * @example
     * // Create one ScrapingJob
     * const ScrapingJob = await prisma.scrapingJob.create({
     *   data: {
     *     // ... data to create a ScrapingJob
     *   }
     * })
     * 
     */
    create<T extends ScrapingJobCreateArgs>(args: SelectSubset<T, ScrapingJobCreateArgs<ExtArgs>>): Prisma__ScrapingJobClient<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScrapingJobs.
     * @param {ScrapingJobCreateManyArgs} args - Arguments to create many ScrapingJobs.
     * @example
     * // Create many ScrapingJobs
     * const scrapingJob = await prisma.scrapingJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScrapingJobCreateManyArgs>(args?: SelectSubset<T, ScrapingJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScrapingJobs and returns the data saved in the database.
     * @param {ScrapingJobCreateManyAndReturnArgs} args - Arguments to create many ScrapingJobs.
     * @example
     * // Create many ScrapingJobs
     * const scrapingJob = await prisma.scrapingJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScrapingJobs and only return the `id`
     * const scrapingJobWithIdOnly = await prisma.scrapingJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScrapingJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ScrapingJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScrapingJob.
     * @param {ScrapingJobDeleteArgs} args - Arguments to delete one ScrapingJob.
     * @example
     * // Delete one ScrapingJob
     * const ScrapingJob = await prisma.scrapingJob.delete({
     *   where: {
     *     // ... filter to delete one ScrapingJob
     *   }
     * })
     * 
     */
    delete<T extends ScrapingJobDeleteArgs>(args: SelectSubset<T, ScrapingJobDeleteArgs<ExtArgs>>): Prisma__ScrapingJobClient<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScrapingJob.
     * @param {ScrapingJobUpdateArgs} args - Arguments to update one ScrapingJob.
     * @example
     * // Update one ScrapingJob
     * const scrapingJob = await prisma.scrapingJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScrapingJobUpdateArgs>(args: SelectSubset<T, ScrapingJobUpdateArgs<ExtArgs>>): Prisma__ScrapingJobClient<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScrapingJobs.
     * @param {ScrapingJobDeleteManyArgs} args - Arguments to filter ScrapingJobs to delete.
     * @example
     * // Delete a few ScrapingJobs
     * const { count } = await prisma.scrapingJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScrapingJobDeleteManyArgs>(args?: SelectSubset<T, ScrapingJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScrapingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrapingJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScrapingJobs
     * const scrapingJob = await prisma.scrapingJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScrapingJobUpdateManyArgs>(args: SelectSubset<T, ScrapingJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScrapingJob.
     * @param {ScrapingJobUpsertArgs} args - Arguments to update or create a ScrapingJob.
     * @example
     * // Update or create a ScrapingJob
     * const scrapingJob = await prisma.scrapingJob.upsert({
     *   create: {
     *     // ... data to create a ScrapingJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScrapingJob we want to update
     *   }
     * })
     */
    upsert<T extends ScrapingJobUpsertArgs>(args: SelectSubset<T, ScrapingJobUpsertArgs<ExtArgs>>): Prisma__ScrapingJobClient<$Result.GetResult<Prisma.$ScrapingJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScrapingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrapingJobCountArgs} args - Arguments to filter ScrapingJobs to count.
     * @example
     * // Count the number of ScrapingJobs
     * const count = await prisma.scrapingJob.count({
     *   where: {
     *     // ... the filter for the ScrapingJobs we want to count
     *   }
     * })
    **/
    count<T extends ScrapingJobCountArgs>(
      args?: Subset<T, ScrapingJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScrapingJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScrapingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrapingJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScrapingJobAggregateArgs>(args: Subset<T, ScrapingJobAggregateArgs>): Prisma.PrismaPromise<GetScrapingJobAggregateType<T>>

    /**
     * Group by ScrapingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrapingJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScrapingJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScrapingJobGroupByArgs['orderBy'] }
        : { orderBy?: ScrapingJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScrapingJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScrapingJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScrapingJob model
   */
  readonly fields: ScrapingJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScrapingJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScrapingJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScrapingJob model
   */ 
  interface ScrapingJobFieldRefs {
    readonly id: FieldRef<"ScrapingJob", 'String'>
    readonly source: FieldRef<"ScrapingJob", 'String'>
    readonly status: FieldRef<"ScrapingJob", 'String'>
    readonly config: FieldRef<"ScrapingJob", 'String'>
    readonly recordsFound: FieldRef<"ScrapingJob", 'Int'>
    readonly recordsSaved: FieldRef<"ScrapingJob", 'Int'>
    readonly errorCount: FieldRef<"ScrapingJob", 'Int'>
    readonly logs: FieldRef<"ScrapingJob", 'String'>
    readonly startedAt: FieldRef<"ScrapingJob", 'DateTime'>
    readonly completedAt: FieldRef<"ScrapingJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScrapingJob findUnique
   */
  export type ScrapingJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * Filter, which ScrapingJob to fetch.
     */
    where: ScrapingJobWhereUniqueInput
  }

  /**
   * ScrapingJob findUniqueOrThrow
   */
  export type ScrapingJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * Filter, which ScrapingJob to fetch.
     */
    where: ScrapingJobWhereUniqueInput
  }

  /**
   * ScrapingJob findFirst
   */
  export type ScrapingJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * Filter, which ScrapingJob to fetch.
     */
    where?: ScrapingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScrapingJobs to fetch.
     */
    orderBy?: ScrapingJobOrderByWithRelationInput | ScrapingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScrapingJobs.
     */
    cursor?: ScrapingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScrapingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScrapingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScrapingJobs.
     */
    distinct?: ScrapingJobScalarFieldEnum | ScrapingJobScalarFieldEnum[]
  }

  /**
   * ScrapingJob findFirstOrThrow
   */
  export type ScrapingJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * Filter, which ScrapingJob to fetch.
     */
    where?: ScrapingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScrapingJobs to fetch.
     */
    orderBy?: ScrapingJobOrderByWithRelationInput | ScrapingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScrapingJobs.
     */
    cursor?: ScrapingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScrapingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScrapingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScrapingJobs.
     */
    distinct?: ScrapingJobScalarFieldEnum | ScrapingJobScalarFieldEnum[]
  }

  /**
   * ScrapingJob findMany
   */
  export type ScrapingJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * Filter, which ScrapingJobs to fetch.
     */
    where?: ScrapingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScrapingJobs to fetch.
     */
    orderBy?: ScrapingJobOrderByWithRelationInput | ScrapingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScrapingJobs.
     */
    cursor?: ScrapingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScrapingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScrapingJobs.
     */
    skip?: number
    distinct?: ScrapingJobScalarFieldEnum | ScrapingJobScalarFieldEnum[]
  }

  /**
   * ScrapingJob create
   */
  export type ScrapingJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * The data needed to create a ScrapingJob.
     */
    data: XOR<ScrapingJobCreateInput, ScrapingJobUncheckedCreateInput>
  }

  /**
   * ScrapingJob createMany
   */
  export type ScrapingJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScrapingJobs.
     */
    data: ScrapingJobCreateManyInput | ScrapingJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScrapingJob createManyAndReturn
   */
  export type ScrapingJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScrapingJobs.
     */
    data: ScrapingJobCreateManyInput | ScrapingJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScrapingJob update
   */
  export type ScrapingJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * The data needed to update a ScrapingJob.
     */
    data: XOR<ScrapingJobUpdateInput, ScrapingJobUncheckedUpdateInput>
    /**
     * Choose, which ScrapingJob to update.
     */
    where: ScrapingJobWhereUniqueInput
  }

  /**
   * ScrapingJob updateMany
   */
  export type ScrapingJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScrapingJobs.
     */
    data: XOR<ScrapingJobUpdateManyMutationInput, ScrapingJobUncheckedUpdateManyInput>
    /**
     * Filter which ScrapingJobs to update
     */
    where?: ScrapingJobWhereInput
  }

  /**
   * ScrapingJob upsert
   */
  export type ScrapingJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * The filter to search for the ScrapingJob to update in case it exists.
     */
    where: ScrapingJobWhereUniqueInput
    /**
     * In case the ScrapingJob found by the `where` argument doesn't exist, create a new ScrapingJob with this data.
     */
    create: XOR<ScrapingJobCreateInput, ScrapingJobUncheckedCreateInput>
    /**
     * In case the ScrapingJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScrapingJobUpdateInput, ScrapingJobUncheckedUpdateInput>
  }

  /**
   * ScrapingJob delete
   */
  export type ScrapingJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
    /**
     * Filter which ScrapingJob to delete.
     */
    where: ScrapingJobWhereUniqueInput
  }

  /**
   * ScrapingJob deleteMany
   */
  export type ScrapingJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScrapingJobs to delete
     */
    where?: ScrapingJobWhereInput
  }

  /**
   * ScrapingJob without action
   */
  export type ScrapingJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrapingJob
     */
    select?: ScrapingJobSelect<ExtArgs> | null
  }


  /**
   * Model PropertyRecord
   */

  export type AggregatePropertyRecord = {
    _count: PropertyRecordCountAggregateOutputType | null
    _min: PropertyRecordMinAggregateOutputType | null
    _max: PropertyRecordMaxAggregateOutputType | null
  }

  export type PropertyRecordMinAggregateOutputType = {
    id: string | null
    source: string | null
    sourceId: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    rawData: string | null
    processed: boolean | null
    propertyHash: string | null
    createdAt: Date | null
  }

  export type PropertyRecordMaxAggregateOutputType = {
    id: string | null
    source: string | null
    sourceId: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    rawData: string | null
    processed: boolean | null
    propertyHash: string | null
    createdAt: Date | null
  }

  export type PropertyRecordCountAggregateOutputType = {
    id: number
    source: number
    sourceId: number
    address: number
    city: number
    state: number
    zipCode: number
    rawData: number
    processed: number
    propertyHash: number
    createdAt: number
    _all: number
  }


  export type PropertyRecordMinAggregateInputType = {
    id?: true
    source?: true
    sourceId?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    rawData?: true
    processed?: true
    propertyHash?: true
    createdAt?: true
  }

  export type PropertyRecordMaxAggregateInputType = {
    id?: true
    source?: true
    sourceId?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    rawData?: true
    processed?: true
    propertyHash?: true
    createdAt?: true
  }

  export type PropertyRecordCountAggregateInputType = {
    id?: true
    source?: true
    sourceId?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    rawData?: true
    processed?: true
    propertyHash?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyRecord to aggregate.
     */
    where?: PropertyRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyRecords to fetch.
     */
    orderBy?: PropertyRecordOrderByWithRelationInput | PropertyRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyRecords
    **/
    _count?: true | PropertyRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyRecordMaxAggregateInputType
  }

  export type GetPropertyRecordAggregateType<T extends PropertyRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyRecord[P]>
      : GetScalarType<T[P], AggregatePropertyRecord[P]>
  }




  export type PropertyRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyRecordWhereInput
    orderBy?: PropertyRecordOrderByWithAggregationInput | PropertyRecordOrderByWithAggregationInput[]
    by: PropertyRecordScalarFieldEnum[] | PropertyRecordScalarFieldEnum
    having?: PropertyRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyRecordCountAggregateInputType | true
    _min?: PropertyRecordMinAggregateInputType
    _max?: PropertyRecordMaxAggregateInputType
  }

  export type PropertyRecordGroupByOutputType = {
    id: string
    source: string
    sourceId: string | null
    address: string
    city: string
    state: string
    zipCode: string
    rawData: string
    processed: boolean
    propertyHash: string
    createdAt: Date
    _count: PropertyRecordCountAggregateOutputType | null
    _min: PropertyRecordMinAggregateOutputType | null
    _max: PropertyRecordMaxAggregateOutputType | null
  }

  type GetPropertyRecordGroupByPayload<T extends PropertyRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyRecordGroupByOutputType[P]>
        }
      >
    >


  export type PropertyRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    sourceId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    rawData?: boolean
    processed?: boolean
    propertyHash?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["propertyRecord"]>

  export type PropertyRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    sourceId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    rawData?: boolean
    processed?: boolean
    propertyHash?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["propertyRecord"]>

  export type PropertyRecordSelectScalar = {
    id?: boolean
    source?: boolean
    sourceId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    rawData?: boolean
    processed?: boolean
    propertyHash?: boolean
    createdAt?: boolean
  }


  export type $PropertyRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: string
      sourceId: string | null
      address: string
      city: string
      state: string
      zipCode: string
      rawData: string
      processed: boolean
      propertyHash: string
      createdAt: Date
    }, ExtArgs["result"]["propertyRecord"]>
    composites: {}
  }

  type PropertyRecordGetPayload<S extends boolean | null | undefined | PropertyRecordDefaultArgs> = $Result.GetResult<Prisma.$PropertyRecordPayload, S>

  type PropertyRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyRecordCountAggregateInputType | true
    }

  export interface PropertyRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyRecord'], meta: { name: 'PropertyRecord' } }
    /**
     * Find zero or one PropertyRecord that matches the filter.
     * @param {PropertyRecordFindUniqueArgs} args - Arguments to find a PropertyRecord
     * @example
     * // Get one PropertyRecord
     * const propertyRecord = await prisma.propertyRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyRecordFindUniqueArgs>(args: SelectSubset<T, PropertyRecordFindUniqueArgs<ExtArgs>>): Prisma__PropertyRecordClient<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyRecordFindUniqueOrThrowArgs} args - Arguments to find a PropertyRecord
     * @example
     * // Get one PropertyRecord
     * const propertyRecord = await prisma.propertyRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyRecordClient<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyRecordFindFirstArgs} args - Arguments to find a PropertyRecord
     * @example
     * // Get one PropertyRecord
     * const propertyRecord = await prisma.propertyRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyRecordFindFirstArgs>(args?: SelectSubset<T, PropertyRecordFindFirstArgs<ExtArgs>>): Prisma__PropertyRecordClient<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyRecordFindFirstOrThrowArgs} args - Arguments to find a PropertyRecord
     * @example
     * // Get one PropertyRecord
     * const propertyRecord = await prisma.propertyRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyRecordClient<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyRecords
     * const propertyRecords = await prisma.propertyRecord.findMany()
     * 
     * // Get first 10 PropertyRecords
     * const propertyRecords = await prisma.propertyRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyRecordWithIdOnly = await prisma.propertyRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyRecordFindManyArgs>(args?: SelectSubset<T, PropertyRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyRecord.
     * @param {PropertyRecordCreateArgs} args - Arguments to create a PropertyRecord.
     * @example
     * // Create one PropertyRecord
     * const PropertyRecord = await prisma.propertyRecord.create({
     *   data: {
     *     // ... data to create a PropertyRecord
     *   }
     * })
     * 
     */
    create<T extends PropertyRecordCreateArgs>(args: SelectSubset<T, PropertyRecordCreateArgs<ExtArgs>>): Prisma__PropertyRecordClient<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyRecords.
     * @param {PropertyRecordCreateManyArgs} args - Arguments to create many PropertyRecords.
     * @example
     * // Create many PropertyRecords
     * const propertyRecord = await prisma.propertyRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyRecordCreateManyArgs>(args?: SelectSubset<T, PropertyRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyRecords and returns the data saved in the database.
     * @param {PropertyRecordCreateManyAndReturnArgs} args - Arguments to create many PropertyRecords.
     * @example
     * // Create many PropertyRecords
     * const propertyRecord = await prisma.propertyRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyRecords and only return the `id`
     * const propertyRecordWithIdOnly = await prisma.propertyRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyRecord.
     * @param {PropertyRecordDeleteArgs} args - Arguments to delete one PropertyRecord.
     * @example
     * // Delete one PropertyRecord
     * const PropertyRecord = await prisma.propertyRecord.delete({
     *   where: {
     *     // ... filter to delete one PropertyRecord
     *   }
     * })
     * 
     */
    delete<T extends PropertyRecordDeleteArgs>(args: SelectSubset<T, PropertyRecordDeleteArgs<ExtArgs>>): Prisma__PropertyRecordClient<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyRecord.
     * @param {PropertyRecordUpdateArgs} args - Arguments to update one PropertyRecord.
     * @example
     * // Update one PropertyRecord
     * const propertyRecord = await prisma.propertyRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyRecordUpdateArgs>(args: SelectSubset<T, PropertyRecordUpdateArgs<ExtArgs>>): Prisma__PropertyRecordClient<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyRecords.
     * @param {PropertyRecordDeleteManyArgs} args - Arguments to filter PropertyRecords to delete.
     * @example
     * // Delete a few PropertyRecords
     * const { count } = await prisma.propertyRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyRecordDeleteManyArgs>(args?: SelectSubset<T, PropertyRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyRecords
     * const propertyRecord = await prisma.propertyRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyRecordUpdateManyArgs>(args: SelectSubset<T, PropertyRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyRecord.
     * @param {PropertyRecordUpsertArgs} args - Arguments to update or create a PropertyRecord.
     * @example
     * // Update or create a PropertyRecord
     * const propertyRecord = await prisma.propertyRecord.upsert({
     *   create: {
     *     // ... data to create a PropertyRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyRecord we want to update
     *   }
     * })
     */
    upsert<T extends PropertyRecordUpsertArgs>(args: SelectSubset<T, PropertyRecordUpsertArgs<ExtArgs>>): Prisma__PropertyRecordClient<$Result.GetResult<Prisma.$PropertyRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyRecordCountArgs} args - Arguments to filter PropertyRecords to count.
     * @example
     * // Count the number of PropertyRecords
     * const count = await prisma.propertyRecord.count({
     *   where: {
     *     // ... the filter for the PropertyRecords we want to count
     *   }
     * })
    **/
    count<T extends PropertyRecordCountArgs>(
      args?: Subset<T, PropertyRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyRecordAggregateArgs>(args: Subset<T, PropertyRecordAggregateArgs>): Prisma.PrismaPromise<GetPropertyRecordAggregateType<T>>

    /**
     * Group by PropertyRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyRecordGroupByArgs['orderBy'] }
        : { orderBy?: PropertyRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyRecord model
   */
  readonly fields: PropertyRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyRecord model
   */ 
  interface PropertyRecordFieldRefs {
    readonly id: FieldRef<"PropertyRecord", 'String'>
    readonly source: FieldRef<"PropertyRecord", 'String'>
    readonly sourceId: FieldRef<"PropertyRecord", 'String'>
    readonly address: FieldRef<"PropertyRecord", 'String'>
    readonly city: FieldRef<"PropertyRecord", 'String'>
    readonly state: FieldRef<"PropertyRecord", 'String'>
    readonly zipCode: FieldRef<"PropertyRecord", 'String'>
    readonly rawData: FieldRef<"PropertyRecord", 'String'>
    readonly processed: FieldRef<"PropertyRecord", 'Boolean'>
    readonly propertyHash: FieldRef<"PropertyRecord", 'String'>
    readonly createdAt: FieldRef<"PropertyRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyRecord findUnique
   */
  export type PropertyRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * Filter, which PropertyRecord to fetch.
     */
    where: PropertyRecordWhereUniqueInput
  }

  /**
   * PropertyRecord findUniqueOrThrow
   */
  export type PropertyRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * Filter, which PropertyRecord to fetch.
     */
    where: PropertyRecordWhereUniqueInput
  }

  /**
   * PropertyRecord findFirst
   */
  export type PropertyRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * Filter, which PropertyRecord to fetch.
     */
    where?: PropertyRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyRecords to fetch.
     */
    orderBy?: PropertyRecordOrderByWithRelationInput | PropertyRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyRecords.
     */
    cursor?: PropertyRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyRecords.
     */
    distinct?: PropertyRecordScalarFieldEnum | PropertyRecordScalarFieldEnum[]
  }

  /**
   * PropertyRecord findFirstOrThrow
   */
  export type PropertyRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * Filter, which PropertyRecord to fetch.
     */
    where?: PropertyRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyRecords to fetch.
     */
    orderBy?: PropertyRecordOrderByWithRelationInput | PropertyRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyRecords.
     */
    cursor?: PropertyRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyRecords.
     */
    distinct?: PropertyRecordScalarFieldEnum | PropertyRecordScalarFieldEnum[]
  }

  /**
   * PropertyRecord findMany
   */
  export type PropertyRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * Filter, which PropertyRecords to fetch.
     */
    where?: PropertyRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyRecords to fetch.
     */
    orderBy?: PropertyRecordOrderByWithRelationInput | PropertyRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyRecords.
     */
    cursor?: PropertyRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyRecords.
     */
    skip?: number
    distinct?: PropertyRecordScalarFieldEnum | PropertyRecordScalarFieldEnum[]
  }

  /**
   * PropertyRecord create
   */
  export type PropertyRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * The data needed to create a PropertyRecord.
     */
    data: XOR<PropertyRecordCreateInput, PropertyRecordUncheckedCreateInput>
  }

  /**
   * PropertyRecord createMany
   */
  export type PropertyRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyRecords.
     */
    data: PropertyRecordCreateManyInput | PropertyRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyRecord createManyAndReturn
   */
  export type PropertyRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyRecords.
     */
    data: PropertyRecordCreateManyInput | PropertyRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyRecord update
   */
  export type PropertyRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * The data needed to update a PropertyRecord.
     */
    data: XOR<PropertyRecordUpdateInput, PropertyRecordUncheckedUpdateInput>
    /**
     * Choose, which PropertyRecord to update.
     */
    where: PropertyRecordWhereUniqueInput
  }

  /**
   * PropertyRecord updateMany
   */
  export type PropertyRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyRecords.
     */
    data: XOR<PropertyRecordUpdateManyMutationInput, PropertyRecordUncheckedUpdateManyInput>
    /**
     * Filter which PropertyRecords to update
     */
    where?: PropertyRecordWhereInput
  }

  /**
   * PropertyRecord upsert
   */
  export type PropertyRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * The filter to search for the PropertyRecord to update in case it exists.
     */
    where: PropertyRecordWhereUniqueInput
    /**
     * In case the PropertyRecord found by the `where` argument doesn't exist, create a new PropertyRecord with this data.
     */
    create: XOR<PropertyRecordCreateInput, PropertyRecordUncheckedCreateInput>
    /**
     * In case the PropertyRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyRecordUpdateInput, PropertyRecordUncheckedUpdateInput>
  }

  /**
   * PropertyRecord delete
   */
  export type PropertyRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
    /**
     * Filter which PropertyRecord to delete.
     */
    where: PropertyRecordWhereUniqueInput
  }

  /**
   * PropertyRecord deleteMany
   */
  export type PropertyRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyRecords to delete
     */
    where?: PropertyRecordWhereInput
  }

  /**
   * PropertyRecord without action
   */
  export type PropertyRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyRecord
     */
    select?: PropertyRecordSelect<ExtArgs> | null
  }


  /**
   * Model DailyMetric
   */

  export type AggregateDailyMetric = {
    _count: DailyMetricCountAggregateOutputType | null
    _avg: DailyMetricAvgAggregateOutputType | null
    _sum: DailyMetricSumAggregateOutputType | null
    _min: DailyMetricMinAggregateOutputType | null
    _max: DailyMetricMaxAggregateOutputType | null
  }

  export type DailyMetricAvgAggregateOutputType = {
    leadsGenerated: number | null
    leadsContacted: number | null
    leadsConverted: number | null
    campaignsSent: number | null
    campaignReplies: number | null
    callsMade: number | null
    callsAnswered: number | null
    avgCallDuration: number | null
    skipTracesRun: number | null
    skipTraceSuccess: number | null
    totalSpent: number | null
    revenueGenerated: number | null
  }

  export type DailyMetricSumAggregateOutputType = {
    leadsGenerated: number | null
    leadsContacted: number | null
    leadsConverted: number | null
    campaignsSent: number | null
    campaignReplies: number | null
    callsMade: number | null
    callsAnswered: number | null
    avgCallDuration: number | null
    skipTracesRun: number | null
    skipTraceSuccess: number | null
    totalSpent: number | null
    revenueGenerated: number | null
  }

  export type DailyMetricMinAggregateOutputType = {
    id: string | null
    date: Date | null
    leadsGenerated: number | null
    leadsContacted: number | null
    leadsConverted: number | null
    campaignsSent: number | null
    campaignReplies: number | null
    callsMade: number | null
    callsAnswered: number | null
    avgCallDuration: number | null
    skipTracesRun: number | null
    skipTraceSuccess: number | null
    totalSpent: number | null
    revenueGenerated: number | null
    createdAt: Date | null
  }

  export type DailyMetricMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    leadsGenerated: number | null
    leadsContacted: number | null
    leadsConverted: number | null
    campaignsSent: number | null
    campaignReplies: number | null
    callsMade: number | null
    callsAnswered: number | null
    avgCallDuration: number | null
    skipTracesRun: number | null
    skipTraceSuccess: number | null
    totalSpent: number | null
    revenueGenerated: number | null
    createdAt: Date | null
  }

  export type DailyMetricCountAggregateOutputType = {
    id: number
    date: number
    leadsGenerated: number
    leadsContacted: number
    leadsConverted: number
    campaignsSent: number
    campaignReplies: number
    callsMade: number
    callsAnswered: number
    avgCallDuration: number
    skipTracesRun: number
    skipTraceSuccess: number
    totalSpent: number
    revenueGenerated: number
    createdAt: number
    _all: number
  }


  export type DailyMetricAvgAggregateInputType = {
    leadsGenerated?: true
    leadsContacted?: true
    leadsConverted?: true
    campaignsSent?: true
    campaignReplies?: true
    callsMade?: true
    callsAnswered?: true
    avgCallDuration?: true
    skipTracesRun?: true
    skipTraceSuccess?: true
    totalSpent?: true
    revenueGenerated?: true
  }

  export type DailyMetricSumAggregateInputType = {
    leadsGenerated?: true
    leadsContacted?: true
    leadsConverted?: true
    campaignsSent?: true
    campaignReplies?: true
    callsMade?: true
    callsAnswered?: true
    avgCallDuration?: true
    skipTracesRun?: true
    skipTraceSuccess?: true
    totalSpent?: true
    revenueGenerated?: true
  }

  export type DailyMetricMinAggregateInputType = {
    id?: true
    date?: true
    leadsGenerated?: true
    leadsContacted?: true
    leadsConverted?: true
    campaignsSent?: true
    campaignReplies?: true
    callsMade?: true
    callsAnswered?: true
    avgCallDuration?: true
    skipTracesRun?: true
    skipTraceSuccess?: true
    totalSpent?: true
    revenueGenerated?: true
    createdAt?: true
  }

  export type DailyMetricMaxAggregateInputType = {
    id?: true
    date?: true
    leadsGenerated?: true
    leadsContacted?: true
    leadsConverted?: true
    campaignsSent?: true
    campaignReplies?: true
    callsMade?: true
    callsAnswered?: true
    avgCallDuration?: true
    skipTracesRun?: true
    skipTraceSuccess?: true
    totalSpent?: true
    revenueGenerated?: true
    createdAt?: true
  }

  export type DailyMetricCountAggregateInputType = {
    id?: true
    date?: true
    leadsGenerated?: true
    leadsContacted?: true
    leadsConverted?: true
    campaignsSent?: true
    campaignReplies?: true
    callsMade?: true
    callsAnswered?: true
    avgCallDuration?: true
    skipTracesRun?: true
    skipTraceSuccess?: true
    totalSpent?: true
    revenueGenerated?: true
    createdAt?: true
    _all?: true
  }

  export type DailyMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyMetric to aggregate.
     */
    where?: DailyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyMetrics to fetch.
     */
    orderBy?: DailyMetricOrderByWithRelationInput | DailyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyMetrics
    **/
    _count?: true | DailyMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyMetricMaxAggregateInputType
  }

  export type GetDailyMetricAggregateType<T extends DailyMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyMetric[P]>
      : GetScalarType<T[P], AggregateDailyMetric[P]>
  }




  export type DailyMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyMetricWhereInput
    orderBy?: DailyMetricOrderByWithAggregationInput | DailyMetricOrderByWithAggregationInput[]
    by: DailyMetricScalarFieldEnum[] | DailyMetricScalarFieldEnum
    having?: DailyMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyMetricCountAggregateInputType | true
    _avg?: DailyMetricAvgAggregateInputType
    _sum?: DailyMetricSumAggregateInputType
    _min?: DailyMetricMinAggregateInputType
    _max?: DailyMetricMaxAggregateInputType
  }

  export type DailyMetricGroupByOutputType = {
    id: string
    date: Date
    leadsGenerated: number
    leadsContacted: number
    leadsConverted: number
    campaignsSent: number
    campaignReplies: number
    callsMade: number
    callsAnswered: number
    avgCallDuration: number | null
    skipTracesRun: number
    skipTraceSuccess: number
    totalSpent: number
    revenueGenerated: number
    createdAt: Date
    _count: DailyMetricCountAggregateOutputType | null
    _avg: DailyMetricAvgAggregateOutputType | null
    _sum: DailyMetricSumAggregateOutputType | null
    _min: DailyMetricMinAggregateOutputType | null
    _max: DailyMetricMaxAggregateOutputType | null
  }

  type GetDailyMetricGroupByPayload<T extends DailyMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyMetricGroupByOutputType[P]>
            : GetScalarType<T[P], DailyMetricGroupByOutputType[P]>
        }
      >
    >


  export type DailyMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    leadsGenerated?: boolean
    leadsContacted?: boolean
    leadsConverted?: boolean
    campaignsSent?: boolean
    campaignReplies?: boolean
    callsMade?: boolean
    callsAnswered?: boolean
    avgCallDuration?: boolean
    skipTracesRun?: boolean
    skipTraceSuccess?: boolean
    totalSpent?: boolean
    revenueGenerated?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["dailyMetric"]>

  export type DailyMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    leadsGenerated?: boolean
    leadsContacted?: boolean
    leadsConverted?: boolean
    campaignsSent?: boolean
    campaignReplies?: boolean
    callsMade?: boolean
    callsAnswered?: boolean
    avgCallDuration?: boolean
    skipTracesRun?: boolean
    skipTraceSuccess?: boolean
    totalSpent?: boolean
    revenueGenerated?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["dailyMetric"]>

  export type DailyMetricSelectScalar = {
    id?: boolean
    date?: boolean
    leadsGenerated?: boolean
    leadsContacted?: boolean
    leadsConverted?: boolean
    campaignsSent?: boolean
    campaignReplies?: boolean
    callsMade?: boolean
    callsAnswered?: boolean
    avgCallDuration?: boolean
    skipTracesRun?: boolean
    skipTraceSuccess?: boolean
    totalSpent?: boolean
    revenueGenerated?: boolean
    createdAt?: boolean
  }


  export type $DailyMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      leadsGenerated: number
      leadsContacted: number
      leadsConverted: number
      campaignsSent: number
      campaignReplies: number
      callsMade: number
      callsAnswered: number
      avgCallDuration: number | null
      skipTracesRun: number
      skipTraceSuccess: number
      totalSpent: number
      revenueGenerated: number
      createdAt: Date
    }, ExtArgs["result"]["dailyMetric"]>
    composites: {}
  }

  type DailyMetricGetPayload<S extends boolean | null | undefined | DailyMetricDefaultArgs> = $Result.GetResult<Prisma.$DailyMetricPayload, S>

  type DailyMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyMetricCountAggregateInputType | true
    }

  export interface DailyMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyMetric'], meta: { name: 'DailyMetric' } }
    /**
     * Find zero or one DailyMetric that matches the filter.
     * @param {DailyMetricFindUniqueArgs} args - Arguments to find a DailyMetric
     * @example
     * // Get one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyMetricFindUniqueArgs>(args: SelectSubset<T, DailyMetricFindUniqueArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyMetricFindUniqueOrThrowArgs} args - Arguments to find a DailyMetric
     * @example
     * // Get one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricFindFirstArgs} args - Arguments to find a DailyMetric
     * @example
     * // Get one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyMetricFindFirstArgs>(args?: SelectSubset<T, DailyMetricFindFirstArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricFindFirstOrThrowArgs} args - Arguments to find a DailyMetric
     * @example
     * // Get one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyMetrics
     * const dailyMetrics = await prisma.dailyMetric.findMany()
     * 
     * // Get first 10 DailyMetrics
     * const dailyMetrics = await prisma.dailyMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyMetricWithIdOnly = await prisma.dailyMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyMetricFindManyArgs>(args?: SelectSubset<T, DailyMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyMetric.
     * @param {DailyMetricCreateArgs} args - Arguments to create a DailyMetric.
     * @example
     * // Create one DailyMetric
     * const DailyMetric = await prisma.dailyMetric.create({
     *   data: {
     *     // ... data to create a DailyMetric
     *   }
     * })
     * 
     */
    create<T extends DailyMetricCreateArgs>(args: SelectSubset<T, DailyMetricCreateArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyMetrics.
     * @param {DailyMetricCreateManyArgs} args - Arguments to create many DailyMetrics.
     * @example
     * // Create many DailyMetrics
     * const dailyMetric = await prisma.dailyMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyMetricCreateManyArgs>(args?: SelectSubset<T, DailyMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyMetrics and returns the data saved in the database.
     * @param {DailyMetricCreateManyAndReturnArgs} args - Arguments to create many DailyMetrics.
     * @example
     * // Create many DailyMetrics
     * const dailyMetric = await prisma.dailyMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyMetrics and only return the `id`
     * const dailyMetricWithIdOnly = await prisma.dailyMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyMetric.
     * @param {DailyMetricDeleteArgs} args - Arguments to delete one DailyMetric.
     * @example
     * // Delete one DailyMetric
     * const DailyMetric = await prisma.dailyMetric.delete({
     *   where: {
     *     // ... filter to delete one DailyMetric
     *   }
     * })
     * 
     */
    delete<T extends DailyMetricDeleteArgs>(args: SelectSubset<T, DailyMetricDeleteArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyMetric.
     * @param {DailyMetricUpdateArgs} args - Arguments to update one DailyMetric.
     * @example
     * // Update one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyMetricUpdateArgs>(args: SelectSubset<T, DailyMetricUpdateArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyMetrics.
     * @param {DailyMetricDeleteManyArgs} args - Arguments to filter DailyMetrics to delete.
     * @example
     * // Delete a few DailyMetrics
     * const { count } = await prisma.dailyMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyMetricDeleteManyArgs>(args?: SelectSubset<T, DailyMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyMetrics
     * const dailyMetric = await prisma.dailyMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyMetricUpdateManyArgs>(args: SelectSubset<T, DailyMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyMetric.
     * @param {DailyMetricUpsertArgs} args - Arguments to update or create a DailyMetric.
     * @example
     * // Update or create a DailyMetric
     * const dailyMetric = await prisma.dailyMetric.upsert({
     *   create: {
     *     // ... data to create a DailyMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyMetric we want to update
     *   }
     * })
     */
    upsert<T extends DailyMetricUpsertArgs>(args: SelectSubset<T, DailyMetricUpsertArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricCountArgs} args - Arguments to filter DailyMetrics to count.
     * @example
     * // Count the number of DailyMetrics
     * const count = await prisma.dailyMetric.count({
     *   where: {
     *     // ... the filter for the DailyMetrics we want to count
     *   }
     * })
    **/
    count<T extends DailyMetricCountArgs>(
      args?: Subset<T, DailyMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyMetricAggregateArgs>(args: Subset<T, DailyMetricAggregateArgs>): Prisma.PrismaPromise<GetDailyMetricAggregateType<T>>

    /**
     * Group by DailyMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyMetricGroupByArgs['orderBy'] }
        : { orderBy?: DailyMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyMetric model
   */
  readonly fields: DailyMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyMetric model
   */ 
  interface DailyMetricFieldRefs {
    readonly id: FieldRef<"DailyMetric", 'String'>
    readonly date: FieldRef<"DailyMetric", 'DateTime'>
    readonly leadsGenerated: FieldRef<"DailyMetric", 'Int'>
    readonly leadsContacted: FieldRef<"DailyMetric", 'Int'>
    readonly leadsConverted: FieldRef<"DailyMetric", 'Int'>
    readonly campaignsSent: FieldRef<"DailyMetric", 'Int'>
    readonly campaignReplies: FieldRef<"DailyMetric", 'Int'>
    readonly callsMade: FieldRef<"DailyMetric", 'Int'>
    readonly callsAnswered: FieldRef<"DailyMetric", 'Int'>
    readonly avgCallDuration: FieldRef<"DailyMetric", 'Float'>
    readonly skipTracesRun: FieldRef<"DailyMetric", 'Int'>
    readonly skipTraceSuccess: FieldRef<"DailyMetric", 'Int'>
    readonly totalSpent: FieldRef<"DailyMetric", 'Float'>
    readonly revenueGenerated: FieldRef<"DailyMetric", 'Float'>
    readonly createdAt: FieldRef<"DailyMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyMetric findUnique
   */
  export type DailyMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetric to fetch.
     */
    where: DailyMetricWhereUniqueInput
  }

  /**
   * DailyMetric findUniqueOrThrow
   */
  export type DailyMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetric to fetch.
     */
    where: DailyMetricWhereUniqueInput
  }

  /**
   * DailyMetric findFirst
   */
  export type DailyMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetric to fetch.
     */
    where?: DailyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyMetrics to fetch.
     */
    orderBy?: DailyMetricOrderByWithRelationInput | DailyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyMetrics.
     */
    cursor?: DailyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyMetrics.
     */
    distinct?: DailyMetricScalarFieldEnum | DailyMetricScalarFieldEnum[]
  }

  /**
   * DailyMetric findFirstOrThrow
   */
  export type DailyMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetric to fetch.
     */
    where?: DailyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyMetrics to fetch.
     */
    orderBy?: DailyMetricOrderByWithRelationInput | DailyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyMetrics.
     */
    cursor?: DailyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyMetrics.
     */
    distinct?: DailyMetricScalarFieldEnum | DailyMetricScalarFieldEnum[]
  }

  /**
   * DailyMetric findMany
   */
  export type DailyMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetrics to fetch.
     */
    where?: DailyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyMetrics to fetch.
     */
    orderBy?: DailyMetricOrderByWithRelationInput | DailyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyMetrics.
     */
    cursor?: DailyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyMetrics.
     */
    skip?: number
    distinct?: DailyMetricScalarFieldEnum | DailyMetricScalarFieldEnum[]
  }

  /**
   * DailyMetric create
   */
  export type DailyMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * The data needed to create a DailyMetric.
     */
    data: XOR<DailyMetricCreateInput, DailyMetricUncheckedCreateInput>
  }

  /**
   * DailyMetric createMany
   */
  export type DailyMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyMetrics.
     */
    data: DailyMetricCreateManyInput | DailyMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyMetric createManyAndReturn
   */
  export type DailyMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyMetrics.
     */
    data: DailyMetricCreateManyInput | DailyMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyMetric update
   */
  export type DailyMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * The data needed to update a DailyMetric.
     */
    data: XOR<DailyMetricUpdateInput, DailyMetricUncheckedUpdateInput>
    /**
     * Choose, which DailyMetric to update.
     */
    where: DailyMetricWhereUniqueInput
  }

  /**
   * DailyMetric updateMany
   */
  export type DailyMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyMetrics.
     */
    data: XOR<DailyMetricUpdateManyMutationInput, DailyMetricUncheckedUpdateManyInput>
    /**
     * Filter which DailyMetrics to update
     */
    where?: DailyMetricWhereInput
  }

  /**
   * DailyMetric upsert
   */
  export type DailyMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * The filter to search for the DailyMetric to update in case it exists.
     */
    where: DailyMetricWhereUniqueInput
    /**
     * In case the DailyMetric found by the `where` argument doesn't exist, create a new DailyMetric with this data.
     */
    create: XOR<DailyMetricCreateInput, DailyMetricUncheckedCreateInput>
    /**
     * In case the DailyMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyMetricUpdateInput, DailyMetricUncheckedUpdateInput>
  }

  /**
   * DailyMetric delete
   */
  export type DailyMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter which DailyMetric to delete.
     */
    where: DailyMetricWhereUniqueInput
  }

  /**
   * DailyMetric deleteMany
   */
  export type DailyMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyMetrics to delete
     */
    where?: DailyMetricWhereInput
  }

  /**
   * DailyMetric without action
   */
  export type DailyMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
  }


  /**
   * Model ScraperJob
   */

  export type AggregateScraperJob = {
    _count: ScraperJobCountAggregateOutputType | null
    _min: ScraperJobMinAggregateOutputType | null
    _max: ScraperJobMaxAggregateOutputType | null
  }

  export type ScraperJobMinAggregateOutputType = {
    id: string | null
    source: $Enums.ScraperSource | null
    status: $Enums.JobStatus | null
    startedAt: Date | null
    finishedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScraperJobMaxAggregateOutputType = {
    id: string | null
    source: $Enums.ScraperSource | null
    status: $Enums.JobStatus | null
    startedAt: Date | null
    finishedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScraperJobCountAggregateOutputType = {
    id: number
    source: number
    inputPayload: number
    resultPayload: number
    status: number
    startedAt: number
    finishedAt: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScraperJobMinAggregateInputType = {
    id?: true
    source?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScraperJobMaxAggregateInputType = {
    id?: true
    source?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScraperJobCountAggregateInputType = {
    id?: true
    source?: true
    inputPayload?: true
    resultPayload?: true
    status?: true
    startedAt?: true
    finishedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScraperJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScraperJob to aggregate.
     */
    where?: ScraperJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScraperJobs to fetch.
     */
    orderBy?: ScraperJobOrderByWithRelationInput | ScraperJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScraperJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScraperJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScraperJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScraperJobs
    **/
    _count?: true | ScraperJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScraperJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScraperJobMaxAggregateInputType
  }

  export type GetScraperJobAggregateType<T extends ScraperJobAggregateArgs> = {
        [P in keyof T & keyof AggregateScraperJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScraperJob[P]>
      : GetScalarType<T[P], AggregateScraperJob[P]>
  }




  export type ScraperJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScraperJobWhereInput
    orderBy?: ScraperJobOrderByWithAggregationInput | ScraperJobOrderByWithAggregationInput[]
    by: ScraperJobScalarFieldEnum[] | ScraperJobScalarFieldEnum
    having?: ScraperJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScraperJobCountAggregateInputType | true
    _min?: ScraperJobMinAggregateInputType
    _max?: ScraperJobMaxAggregateInputType
  }

  export type ScraperJobGroupByOutputType = {
    id: string
    source: $Enums.ScraperSource
    inputPayload: JsonValue
    resultPayload: JsonValue | null
    status: $Enums.JobStatus
    startedAt: Date | null
    finishedAt: Date | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScraperJobCountAggregateOutputType | null
    _min: ScraperJobMinAggregateOutputType | null
    _max: ScraperJobMaxAggregateOutputType | null
  }

  type GetScraperJobGroupByPayload<T extends ScraperJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScraperJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScraperJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScraperJobGroupByOutputType[P]>
            : GetScalarType<T[P], ScraperJobGroupByOutputType[P]>
        }
      >
    >


  export type ScraperJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    inputPayload?: boolean
    resultPayload?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scraperJob"]>

  export type ScraperJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    inputPayload?: boolean
    resultPayload?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scraperJob"]>

  export type ScraperJobSelectScalar = {
    id?: boolean
    source?: boolean
    inputPayload?: boolean
    resultPayload?: boolean
    status?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ScraperJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScraperJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: $Enums.ScraperSource
      inputPayload: Prisma.JsonValue
      resultPayload: Prisma.JsonValue | null
      status: $Enums.JobStatus
      startedAt: Date | null
      finishedAt: Date | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scraperJob"]>
    composites: {}
  }

  type ScraperJobGetPayload<S extends boolean | null | undefined | ScraperJobDefaultArgs> = $Result.GetResult<Prisma.$ScraperJobPayload, S>

  type ScraperJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScraperJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScraperJobCountAggregateInputType | true
    }

  export interface ScraperJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScraperJob'], meta: { name: 'ScraperJob' } }
    /**
     * Find zero or one ScraperJob that matches the filter.
     * @param {ScraperJobFindUniqueArgs} args - Arguments to find a ScraperJob
     * @example
     * // Get one ScraperJob
     * const scraperJob = await prisma.scraperJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScraperJobFindUniqueArgs>(args: SelectSubset<T, ScraperJobFindUniqueArgs<ExtArgs>>): Prisma__ScraperJobClient<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScraperJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScraperJobFindUniqueOrThrowArgs} args - Arguments to find a ScraperJob
     * @example
     * // Get one ScraperJob
     * const scraperJob = await prisma.scraperJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScraperJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ScraperJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScraperJobClient<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScraperJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScraperJobFindFirstArgs} args - Arguments to find a ScraperJob
     * @example
     * // Get one ScraperJob
     * const scraperJob = await prisma.scraperJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScraperJobFindFirstArgs>(args?: SelectSubset<T, ScraperJobFindFirstArgs<ExtArgs>>): Prisma__ScraperJobClient<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScraperJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScraperJobFindFirstOrThrowArgs} args - Arguments to find a ScraperJob
     * @example
     * // Get one ScraperJob
     * const scraperJob = await prisma.scraperJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScraperJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ScraperJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScraperJobClient<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScraperJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScraperJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScraperJobs
     * const scraperJobs = await prisma.scraperJob.findMany()
     * 
     * // Get first 10 ScraperJobs
     * const scraperJobs = await prisma.scraperJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scraperJobWithIdOnly = await prisma.scraperJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScraperJobFindManyArgs>(args?: SelectSubset<T, ScraperJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScraperJob.
     * @param {ScraperJobCreateArgs} args - Arguments to create a ScraperJob.
     * @example
     * // Create one ScraperJob
     * const ScraperJob = await prisma.scraperJob.create({
     *   data: {
     *     // ... data to create a ScraperJob
     *   }
     * })
     * 
     */
    create<T extends ScraperJobCreateArgs>(args: SelectSubset<T, ScraperJobCreateArgs<ExtArgs>>): Prisma__ScraperJobClient<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScraperJobs.
     * @param {ScraperJobCreateManyArgs} args - Arguments to create many ScraperJobs.
     * @example
     * // Create many ScraperJobs
     * const scraperJob = await prisma.scraperJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScraperJobCreateManyArgs>(args?: SelectSubset<T, ScraperJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScraperJobs and returns the data saved in the database.
     * @param {ScraperJobCreateManyAndReturnArgs} args - Arguments to create many ScraperJobs.
     * @example
     * // Create many ScraperJobs
     * const scraperJob = await prisma.scraperJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScraperJobs and only return the `id`
     * const scraperJobWithIdOnly = await prisma.scraperJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScraperJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ScraperJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScraperJob.
     * @param {ScraperJobDeleteArgs} args - Arguments to delete one ScraperJob.
     * @example
     * // Delete one ScraperJob
     * const ScraperJob = await prisma.scraperJob.delete({
     *   where: {
     *     // ... filter to delete one ScraperJob
     *   }
     * })
     * 
     */
    delete<T extends ScraperJobDeleteArgs>(args: SelectSubset<T, ScraperJobDeleteArgs<ExtArgs>>): Prisma__ScraperJobClient<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScraperJob.
     * @param {ScraperJobUpdateArgs} args - Arguments to update one ScraperJob.
     * @example
     * // Update one ScraperJob
     * const scraperJob = await prisma.scraperJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScraperJobUpdateArgs>(args: SelectSubset<T, ScraperJobUpdateArgs<ExtArgs>>): Prisma__ScraperJobClient<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScraperJobs.
     * @param {ScraperJobDeleteManyArgs} args - Arguments to filter ScraperJobs to delete.
     * @example
     * // Delete a few ScraperJobs
     * const { count } = await prisma.scraperJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScraperJobDeleteManyArgs>(args?: SelectSubset<T, ScraperJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScraperJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScraperJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScraperJobs
     * const scraperJob = await prisma.scraperJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScraperJobUpdateManyArgs>(args: SelectSubset<T, ScraperJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScraperJob.
     * @param {ScraperJobUpsertArgs} args - Arguments to update or create a ScraperJob.
     * @example
     * // Update or create a ScraperJob
     * const scraperJob = await prisma.scraperJob.upsert({
     *   create: {
     *     // ... data to create a ScraperJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScraperJob we want to update
     *   }
     * })
     */
    upsert<T extends ScraperJobUpsertArgs>(args: SelectSubset<T, ScraperJobUpsertArgs<ExtArgs>>): Prisma__ScraperJobClient<$Result.GetResult<Prisma.$ScraperJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScraperJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScraperJobCountArgs} args - Arguments to filter ScraperJobs to count.
     * @example
     * // Count the number of ScraperJobs
     * const count = await prisma.scraperJob.count({
     *   where: {
     *     // ... the filter for the ScraperJobs we want to count
     *   }
     * })
    **/
    count<T extends ScraperJobCountArgs>(
      args?: Subset<T, ScraperJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScraperJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScraperJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScraperJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScraperJobAggregateArgs>(args: Subset<T, ScraperJobAggregateArgs>): Prisma.PrismaPromise<GetScraperJobAggregateType<T>>

    /**
     * Group by ScraperJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScraperJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScraperJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScraperJobGroupByArgs['orderBy'] }
        : { orderBy?: ScraperJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScraperJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScraperJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScraperJob model
   */
  readonly fields: ScraperJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScraperJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScraperJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScraperJob model
   */ 
  interface ScraperJobFieldRefs {
    readonly id: FieldRef<"ScraperJob", 'String'>
    readonly source: FieldRef<"ScraperJob", 'ScraperSource'>
    readonly inputPayload: FieldRef<"ScraperJob", 'Json'>
    readonly resultPayload: FieldRef<"ScraperJob", 'Json'>
    readonly status: FieldRef<"ScraperJob", 'JobStatus'>
    readonly startedAt: FieldRef<"ScraperJob", 'DateTime'>
    readonly finishedAt: FieldRef<"ScraperJob", 'DateTime'>
    readonly error: FieldRef<"ScraperJob", 'String'>
    readonly createdAt: FieldRef<"ScraperJob", 'DateTime'>
    readonly updatedAt: FieldRef<"ScraperJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScraperJob findUnique
   */
  export type ScraperJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * Filter, which ScraperJob to fetch.
     */
    where: ScraperJobWhereUniqueInput
  }

  /**
   * ScraperJob findUniqueOrThrow
   */
  export type ScraperJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * Filter, which ScraperJob to fetch.
     */
    where: ScraperJobWhereUniqueInput
  }

  /**
   * ScraperJob findFirst
   */
  export type ScraperJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * Filter, which ScraperJob to fetch.
     */
    where?: ScraperJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScraperJobs to fetch.
     */
    orderBy?: ScraperJobOrderByWithRelationInput | ScraperJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScraperJobs.
     */
    cursor?: ScraperJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScraperJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScraperJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScraperJobs.
     */
    distinct?: ScraperJobScalarFieldEnum | ScraperJobScalarFieldEnum[]
  }

  /**
   * ScraperJob findFirstOrThrow
   */
  export type ScraperJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * Filter, which ScraperJob to fetch.
     */
    where?: ScraperJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScraperJobs to fetch.
     */
    orderBy?: ScraperJobOrderByWithRelationInput | ScraperJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScraperJobs.
     */
    cursor?: ScraperJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScraperJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScraperJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScraperJobs.
     */
    distinct?: ScraperJobScalarFieldEnum | ScraperJobScalarFieldEnum[]
  }

  /**
   * ScraperJob findMany
   */
  export type ScraperJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * Filter, which ScraperJobs to fetch.
     */
    where?: ScraperJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScraperJobs to fetch.
     */
    orderBy?: ScraperJobOrderByWithRelationInput | ScraperJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScraperJobs.
     */
    cursor?: ScraperJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScraperJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScraperJobs.
     */
    skip?: number
    distinct?: ScraperJobScalarFieldEnum | ScraperJobScalarFieldEnum[]
  }

  /**
   * ScraperJob create
   */
  export type ScraperJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * The data needed to create a ScraperJob.
     */
    data: XOR<ScraperJobCreateInput, ScraperJobUncheckedCreateInput>
  }

  /**
   * ScraperJob createMany
   */
  export type ScraperJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScraperJobs.
     */
    data: ScraperJobCreateManyInput | ScraperJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScraperJob createManyAndReturn
   */
  export type ScraperJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScraperJobs.
     */
    data: ScraperJobCreateManyInput | ScraperJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScraperJob update
   */
  export type ScraperJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * The data needed to update a ScraperJob.
     */
    data: XOR<ScraperJobUpdateInput, ScraperJobUncheckedUpdateInput>
    /**
     * Choose, which ScraperJob to update.
     */
    where: ScraperJobWhereUniqueInput
  }

  /**
   * ScraperJob updateMany
   */
  export type ScraperJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScraperJobs.
     */
    data: XOR<ScraperJobUpdateManyMutationInput, ScraperJobUncheckedUpdateManyInput>
    /**
     * Filter which ScraperJobs to update
     */
    where?: ScraperJobWhereInput
  }

  /**
   * ScraperJob upsert
   */
  export type ScraperJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * The filter to search for the ScraperJob to update in case it exists.
     */
    where: ScraperJobWhereUniqueInput
    /**
     * In case the ScraperJob found by the `where` argument doesn't exist, create a new ScraperJob with this data.
     */
    create: XOR<ScraperJobCreateInput, ScraperJobUncheckedCreateInput>
    /**
     * In case the ScraperJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScraperJobUpdateInput, ScraperJobUncheckedUpdateInput>
  }

  /**
   * ScraperJob delete
   */
  export type ScraperJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
    /**
     * Filter which ScraperJob to delete.
     */
    where: ScraperJobWhereUniqueInput
  }

  /**
   * ScraperJob deleteMany
   */
  export type ScraperJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScraperJobs to delete
     */
    where?: ScraperJobWhereInput
  }

  /**
   * ScraperJob without action
   */
  export type ScraperJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScraperJob
     */
    select?: ScraperJobSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    plan: 'plan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    monthlyLeadCount: 'monthlyLeadCount',
    monthlySkipTraceCount: 'monthlySkipTraceCount',
    monthlyCampaignCount: 'monthlyCampaignCount'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organizationId: 'organizationId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    status: 'status',
    source: 'source',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    propertyAddress: 'propertyAddress',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    propertyType: 'propertyType',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    squareFootage: 'squareFootage',
    lotSize: 'lotSize',
    yearBuilt: 'yearBuilt',
    normalizedAddress: 'normalizedAddress',
    listPrice: 'listPrice',
    arv: 'arv',
    estimatedValue: 'estimatedValue',
    estimatedRepairs: 'estimatedRepairs',
    marketValue: 'marketValue',
    loanAmount: 'loanAmount',
    equity: 'equity',
    equityPercent: 'equityPercent',
    lastSalePrice: 'lastSalePrice',
    lastSaleDate: 'lastSaleDate',
    taxAssessedValue: 'taxAssessedValue',
    ownerName: 'ownerName',
    ownerPhone: 'ownerPhone',
    ownerEmail: 'ownerEmail',
    ownerAddress: 'ownerAddress',
    isAbsenteeOwner: 'isAbsenteeOwner',
    phonesJson: 'phonesJson',
    emailsJson: 'emailsJson',
    skipTraceProvider: 'skipTraceProvider',
    skipTraceCostCents: 'skipTraceCostCents',
    skipTracedAt: 'skipTracedAt',
    dncFlag: 'dncFlag',
    motivationScore: 'motivationScore',
    motivationFactors: 'motivationFactors',
    distressSignals: 'distressSignals',
    timeOnMarket: 'timeOnMarket',
    priceReductions: 'priceReductions',
    aiScore: 'aiScore',
    aiCostCents: 'aiCostCents',
    aiScoredAt: 'aiScoredAt',
    aiSummary: 'aiSummary',
    dealPotential: 'dealPotential',
    profitEstimate: 'profitEstimate',
    temperatureTag: 'temperatureTag',
    tags: 'tags',
    isActive: 'isActive',
    organizationId: 'organizationId',
    assignedToId: 'assignedToId'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const LeadNoteScalarFieldEnum: {
    id: 'id',
    content: 'content',
    type: 'type',
    createdAt: 'createdAt',
    leadId: 'leadId'
  };

  export type LeadNoteScalarFieldEnum = (typeof LeadNoteScalarFieldEnum)[keyof typeof LeadNoteScalarFieldEnum]


  export const SkipTraceRecordScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    status: 'status',
    requestData: 'requestData',
    responseData: 'responseData',
    cost: 'cost',
    confidence: 'confidence',
    createdAt: 'createdAt',
    completedAt: 'completedAt',
    leadId: 'leadId'
  };

  export type SkipTraceRecordScalarFieldEnum = (typeof SkipTraceRecordScalarFieldEnum)[keyof typeof SkipTraceRecordScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    subject: 'subject',
    message: 'message',
    script: 'script',
    filters: 'filters',
    targetCount: 'targetCount',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    sent: 'sent',
    delivered: 'delivered',
    opened: 'opened',
    clicked: 'clicked',
    replied: 'replied',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organizationId: 'organizationId'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignLogScalarFieldEnum: {
    id: 'id',
    status: 'status',
    response: 'response',
    errorMessage: 'errorMessage',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    openedAt: 'openedAt',
    repliedAt: 'repliedAt',
    campaignId: 'campaignId',
    leadId: 'leadId',
    userId: 'userId'
  };

  export type CampaignLogScalarFieldEnum = (typeof CampaignLogScalarFieldEnum)[keyof typeof CampaignLogScalarFieldEnum]


  export const CallLogScalarFieldEnum: {
    id: 'id',
    direction: 'direction',
    status: 'status',
    duration: 'duration',
    transcript: 'transcript',
    recording: 'recording',
    fromNumber: 'fromNumber',
    toNumber: 'toNumber',
    twilioCallSid: 'twilioCallSid',
    sentiment: 'sentiment',
    aiSummary: 'aiSummary',
    motivationScore: 'motivationScore',
    outcome: 'outcome',
    followUpDate: 'followUpDate',
    callStartedAt: 'callStartedAt',
    callEndedAt: 'callEndedAt',
    createdAt: 'createdAt',
    leadId: 'leadId',
    organizationId: 'organizationId',
    createdById: 'createdById'
  };

  export type CallLogScalarFieldEnum = (typeof CallLogScalarFieldEnum)[keyof typeof CallLogScalarFieldEnum]


  export const ScrapingJobScalarFieldEnum: {
    id: 'id',
    source: 'source',
    status: 'status',
    config: 'config',
    recordsFound: 'recordsFound',
    recordsSaved: 'recordsSaved',
    errorCount: 'errorCount',
    logs: 'logs',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type ScrapingJobScalarFieldEnum = (typeof ScrapingJobScalarFieldEnum)[keyof typeof ScrapingJobScalarFieldEnum]


  export const PropertyRecordScalarFieldEnum: {
    id: 'id',
    source: 'source',
    sourceId: 'sourceId',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    rawData: 'rawData',
    processed: 'processed',
    propertyHash: 'propertyHash',
    createdAt: 'createdAt'
  };

  export type PropertyRecordScalarFieldEnum = (typeof PropertyRecordScalarFieldEnum)[keyof typeof PropertyRecordScalarFieldEnum]


  export const DailyMetricScalarFieldEnum: {
    id: 'id',
    date: 'date',
    leadsGenerated: 'leadsGenerated',
    leadsContacted: 'leadsContacted',
    leadsConverted: 'leadsConverted',
    campaignsSent: 'campaignsSent',
    campaignReplies: 'campaignReplies',
    callsMade: 'callsMade',
    callsAnswered: 'callsAnswered',
    avgCallDuration: 'avgCallDuration',
    skipTracesRun: 'skipTracesRun',
    skipTraceSuccess: 'skipTraceSuccess',
    totalSpent: 'totalSpent',
    revenueGenerated: 'revenueGenerated',
    createdAt: 'createdAt'
  };

  export type DailyMetricScalarFieldEnum = (typeof DailyMetricScalarFieldEnum)[keyof typeof DailyMetricScalarFieldEnum]


  export const ScraperJobScalarFieldEnum: {
    id: 'id',
    source: 'source',
    inputPayload: 'inputPayload',
    resultPayload: 'resultPayload',
    status: 'status',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScraperJobScalarFieldEnum = (typeof ScraperJobScalarFieldEnum)[keyof typeof ScraperJobScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ScraperSource'
   */
  export type EnumScraperSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScraperSource'>
    


  /**
   * Reference to a field of type 'ScraperSource[]'
   */
  export type ListEnumScraperSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScraperSource[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    plan?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    monthlyLeadCount?: IntFilter<"Organization"> | number
    monthlySkipTraceCount?: IntFilter<"Organization"> | number
    monthlyCampaignCount?: IntFilter<"Organization"> | number
    users?: UserListRelationFilter
    leads?: LeadListRelationFilter
    campaigns?: CampaignListRelationFilter
    callLogs?: CallLogListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    monthlyLeadCount?: SortOrder
    monthlySkipTraceCount?: SortOrder
    monthlyCampaignCount?: SortOrder
    users?: UserOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    callLogs?: CallLogOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    plan?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    monthlyLeadCount?: IntFilter<"Organization"> | number
    monthlySkipTraceCount?: IntFilter<"Organization"> | number
    monthlyCampaignCount?: IntFilter<"Organization"> | number
    users?: UserListRelationFilter
    leads?: LeadListRelationFilter
    campaigns?: CampaignListRelationFilter
    callLogs?: CallLogListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    monthlyLeadCount?: SortOrder
    monthlySkipTraceCount?: SortOrder
    monthlyCampaignCount?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    plan?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    monthlyLeadCount?: IntWithAggregatesFilter<"Organization"> | number
    monthlySkipTraceCount?: IntWithAggregatesFilter<"Organization"> | number
    monthlyCampaignCount?: IntWithAggregatesFilter<"Organization"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organizationId?: StringFilter<"User"> | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    assignedLeads?: LeadListRelationFilter
    callLogs?: CallLogListRelationFilter
    campaignLogs?: CampaignLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    assignedLeads?: LeadOrderByRelationAggregateInput
    callLogs?: CallLogOrderByRelationAggregateInput
    campaignLogs?: CampaignLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organizationId?: StringFilter<"User"> | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    assignedLeads?: LeadListRelationFilter
    callLogs?: CallLogListRelationFilter
    campaignLogs?: CampaignLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    organizationId?: StringWithAggregatesFilter<"User"> | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    status?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    priority?: StringFilter<"Lead"> | string
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    propertyAddress?: StringFilter<"Lead"> | string
    city?: StringFilter<"Lead"> | string
    state?: StringFilter<"Lead"> | string
    zipCode?: StringFilter<"Lead"> | string
    propertyType?: StringNullableFilter<"Lead"> | string | null
    bedrooms?: IntNullableFilter<"Lead"> | number | null
    bathrooms?: FloatNullableFilter<"Lead"> | number | null
    squareFootage?: IntNullableFilter<"Lead"> | number | null
    lotSize?: FloatNullableFilter<"Lead"> | number | null
    yearBuilt?: IntNullableFilter<"Lead"> | number | null
    normalizedAddress?: StringNullableFilter<"Lead"> | string | null
    listPrice?: FloatNullableFilter<"Lead"> | number | null
    arv?: FloatNullableFilter<"Lead"> | number | null
    estimatedValue?: IntNullableFilter<"Lead"> | number | null
    estimatedRepairs?: FloatNullableFilter<"Lead"> | number | null
    marketValue?: FloatNullableFilter<"Lead"> | number | null
    loanAmount?: FloatNullableFilter<"Lead"> | number | null
    equity?: IntNullableFilter<"Lead"> | number | null
    equityPercent?: FloatNullableFilter<"Lead"> | number | null
    lastSalePrice?: FloatNullableFilter<"Lead"> | number | null
    lastSaleDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    taxAssessedValue?: FloatNullableFilter<"Lead"> | number | null
    ownerName?: StringNullableFilter<"Lead"> | string | null
    ownerPhone?: StringNullableFilter<"Lead"> | string | null
    ownerEmail?: StringNullableFilter<"Lead"> | string | null
    ownerAddress?: StringNullableFilter<"Lead"> | string | null
    isAbsenteeOwner?: BoolFilter<"Lead"> | boolean
    phonesJson?: StringNullableFilter<"Lead"> | string | null
    emailsJson?: StringNullableFilter<"Lead"> | string | null
    skipTraceProvider?: StringNullableFilter<"Lead"> | string | null
    skipTraceCostCents?: IntNullableFilter<"Lead"> | number | null
    skipTracedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    dncFlag?: BoolFilter<"Lead"> | boolean
    motivationScore?: FloatNullableFilter<"Lead"> | number | null
    motivationFactors?: StringNullableFilter<"Lead"> | string | null
    distressSignals?: StringNullableFilter<"Lead"> | string | null
    timeOnMarket?: IntNullableFilter<"Lead"> | number | null
    priceReductions?: IntNullableFilter<"Lead"> | number | null
    aiScore?: IntNullableFilter<"Lead"> | number | null
    aiCostCents?: IntNullableFilter<"Lead"> | number | null
    aiScoredAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    aiSummary?: StringNullableFilter<"Lead"> | string | null
    dealPotential?: StringNullableFilter<"Lead"> | string | null
    profitEstimate?: FloatNullableFilter<"Lead"> | number | null
    temperatureTag?: StringNullableFilter<"Lead"> | string | null
    tags?: StringFilter<"Lead"> | string
    isActive?: BoolFilter<"Lead"> | boolean
    organizationId?: StringFilter<"Lead"> | string
    assignedToId?: StringNullableFilter<"Lead"> | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    callLogs?: CallLogListRelationFilter
    campaignLogs?: CampaignLogListRelationFilter
    leadNotes?: LeadNoteListRelationFilter
    skipTraceRecords?: SkipTraceRecordListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    source?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    propertyType?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    squareFootage?: SortOrderInput | SortOrder
    lotSize?: SortOrderInput | SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    normalizedAddress?: SortOrderInput | SortOrder
    listPrice?: SortOrderInput | SortOrder
    arv?: SortOrderInput | SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    estimatedRepairs?: SortOrderInput | SortOrder
    marketValue?: SortOrderInput | SortOrder
    loanAmount?: SortOrderInput | SortOrder
    equity?: SortOrderInput | SortOrder
    equityPercent?: SortOrderInput | SortOrder
    lastSalePrice?: SortOrderInput | SortOrder
    lastSaleDate?: SortOrderInput | SortOrder
    taxAssessedValue?: SortOrderInput | SortOrder
    ownerName?: SortOrderInput | SortOrder
    ownerPhone?: SortOrderInput | SortOrder
    ownerEmail?: SortOrderInput | SortOrder
    ownerAddress?: SortOrderInput | SortOrder
    isAbsenteeOwner?: SortOrder
    phonesJson?: SortOrderInput | SortOrder
    emailsJson?: SortOrderInput | SortOrder
    skipTraceProvider?: SortOrderInput | SortOrder
    skipTraceCostCents?: SortOrderInput | SortOrder
    skipTracedAt?: SortOrderInput | SortOrder
    dncFlag?: SortOrder
    motivationScore?: SortOrderInput | SortOrder
    motivationFactors?: SortOrderInput | SortOrder
    distressSignals?: SortOrderInput | SortOrder
    timeOnMarket?: SortOrderInput | SortOrder
    priceReductions?: SortOrderInput | SortOrder
    aiScore?: SortOrderInput | SortOrder
    aiCostCents?: SortOrderInput | SortOrder
    aiScoredAt?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    dealPotential?: SortOrderInput | SortOrder
    profitEstimate?: SortOrderInput | SortOrder
    temperatureTag?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    callLogs?: CallLogOrderByRelationAggregateInput
    campaignLogs?: CampaignLogOrderByRelationAggregateInput
    leadNotes?: LeadNoteOrderByRelationAggregateInput
    skipTraceRecords?: SkipTraceRecordOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    status?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    priority?: StringFilter<"Lead"> | string
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    propertyAddress?: StringFilter<"Lead"> | string
    city?: StringFilter<"Lead"> | string
    state?: StringFilter<"Lead"> | string
    zipCode?: StringFilter<"Lead"> | string
    propertyType?: StringNullableFilter<"Lead"> | string | null
    bedrooms?: IntNullableFilter<"Lead"> | number | null
    bathrooms?: FloatNullableFilter<"Lead"> | number | null
    squareFootage?: IntNullableFilter<"Lead"> | number | null
    lotSize?: FloatNullableFilter<"Lead"> | number | null
    yearBuilt?: IntNullableFilter<"Lead"> | number | null
    normalizedAddress?: StringNullableFilter<"Lead"> | string | null
    listPrice?: FloatNullableFilter<"Lead"> | number | null
    arv?: FloatNullableFilter<"Lead"> | number | null
    estimatedValue?: IntNullableFilter<"Lead"> | number | null
    estimatedRepairs?: FloatNullableFilter<"Lead"> | number | null
    marketValue?: FloatNullableFilter<"Lead"> | number | null
    loanAmount?: FloatNullableFilter<"Lead"> | number | null
    equity?: IntNullableFilter<"Lead"> | number | null
    equityPercent?: FloatNullableFilter<"Lead"> | number | null
    lastSalePrice?: FloatNullableFilter<"Lead"> | number | null
    lastSaleDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    taxAssessedValue?: FloatNullableFilter<"Lead"> | number | null
    ownerName?: StringNullableFilter<"Lead"> | string | null
    ownerPhone?: StringNullableFilter<"Lead"> | string | null
    ownerEmail?: StringNullableFilter<"Lead"> | string | null
    ownerAddress?: StringNullableFilter<"Lead"> | string | null
    isAbsenteeOwner?: BoolFilter<"Lead"> | boolean
    phonesJson?: StringNullableFilter<"Lead"> | string | null
    emailsJson?: StringNullableFilter<"Lead"> | string | null
    skipTraceProvider?: StringNullableFilter<"Lead"> | string | null
    skipTraceCostCents?: IntNullableFilter<"Lead"> | number | null
    skipTracedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    dncFlag?: BoolFilter<"Lead"> | boolean
    motivationScore?: FloatNullableFilter<"Lead"> | number | null
    motivationFactors?: StringNullableFilter<"Lead"> | string | null
    distressSignals?: StringNullableFilter<"Lead"> | string | null
    timeOnMarket?: IntNullableFilter<"Lead"> | number | null
    priceReductions?: IntNullableFilter<"Lead"> | number | null
    aiScore?: IntNullableFilter<"Lead"> | number | null
    aiCostCents?: IntNullableFilter<"Lead"> | number | null
    aiScoredAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    aiSummary?: StringNullableFilter<"Lead"> | string | null
    dealPotential?: StringNullableFilter<"Lead"> | string | null
    profitEstimate?: FloatNullableFilter<"Lead"> | number | null
    temperatureTag?: StringNullableFilter<"Lead"> | string | null
    tags?: StringFilter<"Lead"> | string
    isActive?: BoolFilter<"Lead"> | boolean
    organizationId?: StringFilter<"Lead"> | string
    assignedToId?: StringNullableFilter<"Lead"> | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    callLogs?: CallLogListRelationFilter
    campaignLogs?: CampaignLogListRelationFilter
    leadNotes?: LeadNoteListRelationFilter
    skipTraceRecords?: SkipTraceRecordListRelationFilter
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    source?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    propertyType?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    squareFootage?: SortOrderInput | SortOrder
    lotSize?: SortOrderInput | SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    normalizedAddress?: SortOrderInput | SortOrder
    listPrice?: SortOrderInput | SortOrder
    arv?: SortOrderInput | SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    estimatedRepairs?: SortOrderInput | SortOrder
    marketValue?: SortOrderInput | SortOrder
    loanAmount?: SortOrderInput | SortOrder
    equity?: SortOrderInput | SortOrder
    equityPercent?: SortOrderInput | SortOrder
    lastSalePrice?: SortOrderInput | SortOrder
    lastSaleDate?: SortOrderInput | SortOrder
    taxAssessedValue?: SortOrderInput | SortOrder
    ownerName?: SortOrderInput | SortOrder
    ownerPhone?: SortOrderInput | SortOrder
    ownerEmail?: SortOrderInput | SortOrder
    ownerAddress?: SortOrderInput | SortOrder
    isAbsenteeOwner?: SortOrder
    phonesJson?: SortOrderInput | SortOrder
    emailsJson?: SortOrderInput | SortOrder
    skipTraceProvider?: SortOrderInput | SortOrder
    skipTraceCostCents?: SortOrderInput | SortOrder
    skipTracedAt?: SortOrderInput | SortOrder
    dncFlag?: SortOrder
    motivationScore?: SortOrderInput | SortOrder
    motivationFactors?: SortOrderInput | SortOrder
    distressSignals?: SortOrderInput | SortOrder
    timeOnMarket?: SortOrderInput | SortOrder
    priceReductions?: SortOrderInput | SortOrder
    aiScore?: SortOrderInput | SortOrder
    aiCostCents?: SortOrderInput | SortOrder
    aiScoredAt?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    dealPotential?: SortOrderInput | SortOrder
    profitEstimate?: SortOrderInput | SortOrder
    temperatureTag?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    status?: StringWithAggregatesFilter<"Lead"> | string
    source?: StringWithAggregatesFilter<"Lead"> | string
    priority?: StringWithAggregatesFilter<"Lead"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    propertyAddress?: StringWithAggregatesFilter<"Lead"> | string
    city?: StringWithAggregatesFilter<"Lead"> | string
    state?: StringWithAggregatesFilter<"Lead"> | string
    zipCode?: StringWithAggregatesFilter<"Lead"> | string
    propertyType?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    bedrooms?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    bathrooms?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    squareFootage?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    lotSize?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    yearBuilt?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    normalizedAddress?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    listPrice?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    arv?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    estimatedValue?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    estimatedRepairs?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    marketValue?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    loanAmount?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    equity?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    equityPercent?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    lastSalePrice?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    lastSaleDate?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    taxAssessedValue?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    ownerName?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    ownerPhone?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    ownerEmail?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    ownerAddress?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    isAbsenteeOwner?: BoolWithAggregatesFilter<"Lead"> | boolean
    phonesJson?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    emailsJson?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    skipTraceProvider?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    skipTraceCostCents?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    skipTracedAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    dncFlag?: BoolWithAggregatesFilter<"Lead"> | boolean
    motivationScore?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    motivationFactors?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    distressSignals?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    timeOnMarket?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    priceReductions?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    aiScore?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    aiCostCents?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    aiScoredAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    aiSummary?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    dealPotential?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    profitEstimate?: FloatNullableWithAggregatesFilter<"Lead"> | number | null
    temperatureTag?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    tags?: StringWithAggregatesFilter<"Lead"> | string
    isActive?: BoolWithAggregatesFilter<"Lead"> | boolean
    organizationId?: StringWithAggregatesFilter<"Lead"> | string
    assignedToId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
  }

  export type LeadNoteWhereInput = {
    AND?: LeadNoteWhereInput | LeadNoteWhereInput[]
    OR?: LeadNoteWhereInput[]
    NOT?: LeadNoteWhereInput | LeadNoteWhereInput[]
    id?: StringFilter<"LeadNote"> | string
    content?: StringFilter<"LeadNote"> | string
    type?: StringFilter<"LeadNote"> | string
    createdAt?: DateTimeFilter<"LeadNote"> | Date | string
    leadId?: StringFilter<"LeadNote"> | string
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
  }

  export type LeadNoteOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    lead?: LeadOrderByWithRelationInput
  }

  export type LeadNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadNoteWhereInput | LeadNoteWhereInput[]
    OR?: LeadNoteWhereInput[]
    NOT?: LeadNoteWhereInput | LeadNoteWhereInput[]
    content?: StringFilter<"LeadNote"> | string
    type?: StringFilter<"LeadNote"> | string
    createdAt?: DateTimeFilter<"LeadNote"> | Date | string
    leadId?: StringFilter<"LeadNote"> | string
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
  }, "id">

  export type LeadNoteOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    _count?: LeadNoteCountOrderByAggregateInput
    _max?: LeadNoteMaxOrderByAggregateInput
    _min?: LeadNoteMinOrderByAggregateInput
  }

  export type LeadNoteScalarWhereWithAggregatesInput = {
    AND?: LeadNoteScalarWhereWithAggregatesInput | LeadNoteScalarWhereWithAggregatesInput[]
    OR?: LeadNoteScalarWhereWithAggregatesInput[]
    NOT?: LeadNoteScalarWhereWithAggregatesInput | LeadNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadNote"> | string
    content?: StringWithAggregatesFilter<"LeadNote"> | string
    type?: StringWithAggregatesFilter<"LeadNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeadNote"> | Date | string
    leadId?: StringWithAggregatesFilter<"LeadNote"> | string
  }

  export type SkipTraceRecordWhereInput = {
    AND?: SkipTraceRecordWhereInput | SkipTraceRecordWhereInput[]
    OR?: SkipTraceRecordWhereInput[]
    NOT?: SkipTraceRecordWhereInput | SkipTraceRecordWhereInput[]
    id?: StringFilter<"SkipTraceRecord"> | string
    provider?: StringFilter<"SkipTraceRecord"> | string
    status?: StringFilter<"SkipTraceRecord"> | string
    requestData?: StringFilter<"SkipTraceRecord"> | string
    responseData?: StringNullableFilter<"SkipTraceRecord"> | string | null
    cost?: FloatNullableFilter<"SkipTraceRecord"> | number | null
    confidence?: FloatNullableFilter<"SkipTraceRecord"> | number | null
    createdAt?: DateTimeFilter<"SkipTraceRecord"> | Date | string
    completedAt?: DateTimeNullableFilter<"SkipTraceRecord"> | Date | string | null
    leadId?: StringFilter<"SkipTraceRecord"> | string
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
  }

  export type SkipTraceRecordOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    leadId?: SortOrder
    lead?: LeadOrderByWithRelationInput
  }

  export type SkipTraceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkipTraceRecordWhereInput | SkipTraceRecordWhereInput[]
    OR?: SkipTraceRecordWhereInput[]
    NOT?: SkipTraceRecordWhereInput | SkipTraceRecordWhereInput[]
    provider?: StringFilter<"SkipTraceRecord"> | string
    status?: StringFilter<"SkipTraceRecord"> | string
    requestData?: StringFilter<"SkipTraceRecord"> | string
    responseData?: StringNullableFilter<"SkipTraceRecord"> | string | null
    cost?: FloatNullableFilter<"SkipTraceRecord"> | number | null
    confidence?: FloatNullableFilter<"SkipTraceRecord"> | number | null
    createdAt?: DateTimeFilter<"SkipTraceRecord"> | Date | string
    completedAt?: DateTimeNullableFilter<"SkipTraceRecord"> | Date | string | null
    leadId?: StringFilter<"SkipTraceRecord"> | string
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
  }, "id">

  export type SkipTraceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    leadId?: SortOrder
    _count?: SkipTraceRecordCountOrderByAggregateInput
    _avg?: SkipTraceRecordAvgOrderByAggregateInput
    _max?: SkipTraceRecordMaxOrderByAggregateInput
    _min?: SkipTraceRecordMinOrderByAggregateInput
    _sum?: SkipTraceRecordSumOrderByAggregateInput
  }

  export type SkipTraceRecordScalarWhereWithAggregatesInput = {
    AND?: SkipTraceRecordScalarWhereWithAggregatesInput | SkipTraceRecordScalarWhereWithAggregatesInput[]
    OR?: SkipTraceRecordScalarWhereWithAggregatesInput[]
    NOT?: SkipTraceRecordScalarWhereWithAggregatesInput | SkipTraceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkipTraceRecord"> | string
    provider?: StringWithAggregatesFilter<"SkipTraceRecord"> | string
    status?: StringWithAggregatesFilter<"SkipTraceRecord"> | string
    requestData?: StringWithAggregatesFilter<"SkipTraceRecord"> | string
    responseData?: StringNullableWithAggregatesFilter<"SkipTraceRecord"> | string | null
    cost?: FloatNullableWithAggregatesFilter<"SkipTraceRecord"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"SkipTraceRecord"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SkipTraceRecord"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SkipTraceRecord"> | Date | string | null
    leadId?: StringWithAggregatesFilter<"SkipTraceRecord"> | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    subject?: StringNullableFilter<"Campaign"> | string | null
    message?: StringFilter<"Campaign"> | string
    script?: StringNullableFilter<"Campaign"> | string | null
    filters?: StringFilter<"Campaign"> | string
    targetCount?: IntFilter<"Campaign"> | number
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sent?: IntFilter<"Campaign"> | number
    delivered?: IntFilter<"Campaign"> | number
    opened?: IntFilter<"Campaign"> | number
    clicked?: IntFilter<"Campaign"> | number
    replied?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    organizationId?: StringFilter<"Campaign"> | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    campaignLogs?: CampaignLogListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    script?: SortOrderInput | SortOrder
    filters?: SortOrder
    targetCount?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    sent?: SortOrder
    delivered?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    replied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    campaignLogs?: CampaignLogOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    subject?: StringNullableFilter<"Campaign"> | string | null
    message?: StringFilter<"Campaign"> | string
    script?: StringNullableFilter<"Campaign"> | string | null
    filters?: StringFilter<"Campaign"> | string
    targetCount?: IntFilter<"Campaign"> | number
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sent?: IntFilter<"Campaign"> | number
    delivered?: IntFilter<"Campaign"> | number
    opened?: IntFilter<"Campaign"> | number
    clicked?: IntFilter<"Campaign"> | number
    replied?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    organizationId?: StringFilter<"Campaign"> | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    campaignLogs?: CampaignLogListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    script?: SortOrderInput | SortOrder
    filters?: SortOrder
    targetCount?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    sent?: SortOrder
    delivered?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    replied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    type?: StringWithAggregatesFilter<"Campaign"> | string
    status?: StringWithAggregatesFilter<"Campaign"> | string
    subject?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    message?: StringWithAggregatesFilter<"Campaign"> | string
    script?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    filters?: StringWithAggregatesFilter<"Campaign"> | string
    targetCount?: IntWithAggregatesFilter<"Campaign"> | number
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    sent?: IntWithAggregatesFilter<"Campaign"> | number
    delivered?: IntWithAggregatesFilter<"Campaign"> | number
    opened?: IntWithAggregatesFilter<"Campaign"> | number
    clicked?: IntWithAggregatesFilter<"Campaign"> | number
    replied?: IntWithAggregatesFilter<"Campaign"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    organizationId?: StringWithAggregatesFilter<"Campaign"> | string
  }

  export type CampaignLogWhereInput = {
    AND?: CampaignLogWhereInput | CampaignLogWhereInput[]
    OR?: CampaignLogWhereInput[]
    NOT?: CampaignLogWhereInput | CampaignLogWhereInput[]
    id?: StringFilter<"CampaignLog"> | string
    status?: StringFilter<"CampaignLog"> | string
    response?: StringNullableFilter<"CampaignLog"> | string | null
    errorMessage?: StringNullableFilter<"CampaignLog"> | string | null
    sentAt?: DateTimeFilter<"CampaignLog"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    repliedAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    campaignId?: StringFilter<"CampaignLog"> | string
    leadId?: StringFilter<"CampaignLog"> | string
    userId?: StringNullableFilter<"CampaignLog"> | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CampaignLogOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    repliedAt?: SortOrderInput | SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    userId?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CampaignLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignLogWhereInput | CampaignLogWhereInput[]
    OR?: CampaignLogWhereInput[]
    NOT?: CampaignLogWhereInput | CampaignLogWhereInput[]
    status?: StringFilter<"CampaignLog"> | string
    response?: StringNullableFilter<"CampaignLog"> | string | null
    errorMessage?: StringNullableFilter<"CampaignLog"> | string | null
    sentAt?: DateTimeFilter<"CampaignLog"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    repliedAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    campaignId?: StringFilter<"CampaignLog"> | string
    leadId?: StringFilter<"CampaignLog"> | string
    userId?: StringNullableFilter<"CampaignLog"> | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CampaignLogOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    repliedAt?: SortOrderInput | SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: CampaignLogCountOrderByAggregateInput
    _max?: CampaignLogMaxOrderByAggregateInput
    _min?: CampaignLogMinOrderByAggregateInput
  }

  export type CampaignLogScalarWhereWithAggregatesInput = {
    AND?: CampaignLogScalarWhereWithAggregatesInput | CampaignLogScalarWhereWithAggregatesInput[]
    OR?: CampaignLogScalarWhereWithAggregatesInput[]
    NOT?: CampaignLogScalarWhereWithAggregatesInput | CampaignLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignLog"> | string
    status?: StringWithAggregatesFilter<"CampaignLog"> | string
    response?: StringNullableWithAggregatesFilter<"CampaignLog"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"CampaignLog"> | string | null
    sentAt?: DateTimeWithAggregatesFilter<"CampaignLog"> | Date | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"CampaignLog"> | Date | string | null
    openedAt?: DateTimeNullableWithAggregatesFilter<"CampaignLog"> | Date | string | null
    repliedAt?: DateTimeNullableWithAggregatesFilter<"CampaignLog"> | Date | string | null
    campaignId?: StringWithAggregatesFilter<"CampaignLog"> | string
    leadId?: StringWithAggregatesFilter<"CampaignLog"> | string
    userId?: StringNullableWithAggregatesFilter<"CampaignLog"> | string | null
  }

  export type CallLogWhereInput = {
    AND?: CallLogWhereInput | CallLogWhereInput[]
    OR?: CallLogWhereInput[]
    NOT?: CallLogWhereInput | CallLogWhereInput[]
    id?: StringFilter<"CallLog"> | string
    direction?: StringFilter<"CallLog"> | string
    status?: StringFilter<"CallLog"> | string
    duration?: IntNullableFilter<"CallLog"> | number | null
    transcript?: StringNullableFilter<"CallLog"> | string | null
    recording?: StringNullableFilter<"CallLog"> | string | null
    fromNumber?: StringFilter<"CallLog"> | string
    toNumber?: StringFilter<"CallLog"> | string
    twilioCallSid?: StringNullableFilter<"CallLog"> | string | null
    sentiment?: StringNullableFilter<"CallLog"> | string | null
    aiSummary?: StringNullableFilter<"CallLog"> | string | null
    motivationScore?: FloatNullableFilter<"CallLog"> | number | null
    outcome?: StringNullableFilter<"CallLog"> | string | null
    followUpDate?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    callStartedAt?: DateTimeFilter<"CallLog"> | Date | string
    callEndedAt?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    createdAt?: DateTimeFilter<"CallLog"> | Date | string
    leadId?: StringFilter<"CallLog"> | string
    organizationId?: StringFilter<"CallLog"> | string
    createdById?: StringFilter<"CallLog"> | string
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CallLogOrderByWithRelationInput = {
    id?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    recording?: SortOrderInput | SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    twilioCallSid?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    motivationScore?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    followUpDate?: SortOrderInput | SortOrder
    callStartedAt?: SortOrder
    callEndedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    organizationId?: SortOrder
    createdById?: SortOrder
    lead?: LeadOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type CallLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallLogWhereInput | CallLogWhereInput[]
    OR?: CallLogWhereInput[]
    NOT?: CallLogWhereInput | CallLogWhereInput[]
    direction?: StringFilter<"CallLog"> | string
    status?: StringFilter<"CallLog"> | string
    duration?: IntNullableFilter<"CallLog"> | number | null
    transcript?: StringNullableFilter<"CallLog"> | string | null
    recording?: StringNullableFilter<"CallLog"> | string | null
    fromNumber?: StringFilter<"CallLog"> | string
    toNumber?: StringFilter<"CallLog"> | string
    twilioCallSid?: StringNullableFilter<"CallLog"> | string | null
    sentiment?: StringNullableFilter<"CallLog"> | string | null
    aiSummary?: StringNullableFilter<"CallLog"> | string | null
    motivationScore?: FloatNullableFilter<"CallLog"> | number | null
    outcome?: StringNullableFilter<"CallLog"> | string | null
    followUpDate?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    callStartedAt?: DateTimeFilter<"CallLog"> | Date | string
    callEndedAt?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    createdAt?: DateTimeFilter<"CallLog"> | Date | string
    leadId?: StringFilter<"CallLog"> | string
    organizationId?: StringFilter<"CallLog"> | string
    createdById?: StringFilter<"CallLog"> | string
    lead?: XOR<LeadRelationFilter, LeadWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CallLogOrderByWithAggregationInput = {
    id?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    recording?: SortOrderInput | SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    twilioCallSid?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    motivationScore?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    followUpDate?: SortOrderInput | SortOrder
    callStartedAt?: SortOrder
    callEndedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    organizationId?: SortOrder
    createdById?: SortOrder
    _count?: CallLogCountOrderByAggregateInput
    _avg?: CallLogAvgOrderByAggregateInput
    _max?: CallLogMaxOrderByAggregateInput
    _min?: CallLogMinOrderByAggregateInput
    _sum?: CallLogSumOrderByAggregateInput
  }

  export type CallLogScalarWhereWithAggregatesInput = {
    AND?: CallLogScalarWhereWithAggregatesInput | CallLogScalarWhereWithAggregatesInput[]
    OR?: CallLogScalarWhereWithAggregatesInput[]
    NOT?: CallLogScalarWhereWithAggregatesInput | CallLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallLog"> | string
    direction?: StringWithAggregatesFilter<"CallLog"> | string
    status?: StringWithAggregatesFilter<"CallLog"> | string
    duration?: IntNullableWithAggregatesFilter<"CallLog"> | number | null
    transcript?: StringNullableWithAggregatesFilter<"CallLog"> | string | null
    recording?: StringNullableWithAggregatesFilter<"CallLog"> | string | null
    fromNumber?: StringWithAggregatesFilter<"CallLog"> | string
    toNumber?: StringWithAggregatesFilter<"CallLog"> | string
    twilioCallSid?: StringNullableWithAggregatesFilter<"CallLog"> | string | null
    sentiment?: StringNullableWithAggregatesFilter<"CallLog"> | string | null
    aiSummary?: StringNullableWithAggregatesFilter<"CallLog"> | string | null
    motivationScore?: FloatNullableWithAggregatesFilter<"CallLog"> | number | null
    outcome?: StringNullableWithAggregatesFilter<"CallLog"> | string | null
    followUpDate?: DateTimeNullableWithAggregatesFilter<"CallLog"> | Date | string | null
    callStartedAt?: DateTimeWithAggregatesFilter<"CallLog"> | Date | string
    callEndedAt?: DateTimeNullableWithAggregatesFilter<"CallLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CallLog"> | Date | string
    leadId?: StringWithAggregatesFilter<"CallLog"> | string
    organizationId?: StringWithAggregatesFilter<"CallLog"> | string
    createdById?: StringWithAggregatesFilter<"CallLog"> | string
  }

  export type ScrapingJobWhereInput = {
    AND?: ScrapingJobWhereInput | ScrapingJobWhereInput[]
    OR?: ScrapingJobWhereInput[]
    NOT?: ScrapingJobWhereInput | ScrapingJobWhereInput[]
    id?: StringFilter<"ScrapingJob"> | string
    source?: StringFilter<"ScrapingJob"> | string
    status?: StringFilter<"ScrapingJob"> | string
    config?: StringFilter<"ScrapingJob"> | string
    recordsFound?: IntFilter<"ScrapingJob"> | number
    recordsSaved?: IntFilter<"ScrapingJob"> | number
    errorCount?: IntFilter<"ScrapingJob"> | number
    logs?: StringNullableFilter<"ScrapingJob"> | string | null
    startedAt?: DateTimeFilter<"ScrapingJob"> | Date | string
    completedAt?: DateTimeNullableFilter<"ScrapingJob"> | Date | string | null
  }

  export type ScrapingJobOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    status?: SortOrder
    config?: SortOrder
    recordsFound?: SortOrder
    recordsSaved?: SortOrder
    errorCount?: SortOrder
    logs?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type ScrapingJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScrapingJobWhereInput | ScrapingJobWhereInput[]
    OR?: ScrapingJobWhereInput[]
    NOT?: ScrapingJobWhereInput | ScrapingJobWhereInput[]
    source?: StringFilter<"ScrapingJob"> | string
    status?: StringFilter<"ScrapingJob"> | string
    config?: StringFilter<"ScrapingJob"> | string
    recordsFound?: IntFilter<"ScrapingJob"> | number
    recordsSaved?: IntFilter<"ScrapingJob"> | number
    errorCount?: IntFilter<"ScrapingJob"> | number
    logs?: StringNullableFilter<"ScrapingJob"> | string | null
    startedAt?: DateTimeFilter<"ScrapingJob"> | Date | string
    completedAt?: DateTimeNullableFilter<"ScrapingJob"> | Date | string | null
  }, "id">

  export type ScrapingJobOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    status?: SortOrder
    config?: SortOrder
    recordsFound?: SortOrder
    recordsSaved?: SortOrder
    errorCount?: SortOrder
    logs?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ScrapingJobCountOrderByAggregateInput
    _avg?: ScrapingJobAvgOrderByAggregateInput
    _max?: ScrapingJobMaxOrderByAggregateInput
    _min?: ScrapingJobMinOrderByAggregateInput
    _sum?: ScrapingJobSumOrderByAggregateInput
  }

  export type ScrapingJobScalarWhereWithAggregatesInput = {
    AND?: ScrapingJobScalarWhereWithAggregatesInput | ScrapingJobScalarWhereWithAggregatesInput[]
    OR?: ScrapingJobScalarWhereWithAggregatesInput[]
    NOT?: ScrapingJobScalarWhereWithAggregatesInput | ScrapingJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScrapingJob"> | string
    source?: StringWithAggregatesFilter<"ScrapingJob"> | string
    status?: StringWithAggregatesFilter<"ScrapingJob"> | string
    config?: StringWithAggregatesFilter<"ScrapingJob"> | string
    recordsFound?: IntWithAggregatesFilter<"ScrapingJob"> | number
    recordsSaved?: IntWithAggregatesFilter<"ScrapingJob"> | number
    errorCount?: IntWithAggregatesFilter<"ScrapingJob"> | number
    logs?: StringNullableWithAggregatesFilter<"ScrapingJob"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"ScrapingJob"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ScrapingJob"> | Date | string | null
  }

  export type PropertyRecordWhereInput = {
    AND?: PropertyRecordWhereInput | PropertyRecordWhereInput[]
    OR?: PropertyRecordWhereInput[]
    NOT?: PropertyRecordWhereInput | PropertyRecordWhereInput[]
    id?: StringFilter<"PropertyRecord"> | string
    source?: StringFilter<"PropertyRecord"> | string
    sourceId?: StringNullableFilter<"PropertyRecord"> | string | null
    address?: StringFilter<"PropertyRecord"> | string
    city?: StringFilter<"PropertyRecord"> | string
    state?: StringFilter<"PropertyRecord"> | string
    zipCode?: StringFilter<"PropertyRecord"> | string
    rawData?: StringFilter<"PropertyRecord"> | string
    processed?: BoolFilter<"PropertyRecord"> | boolean
    propertyHash?: StringFilter<"PropertyRecord"> | string
    createdAt?: DateTimeFilter<"PropertyRecord"> | Date | string
  }

  export type PropertyRecordOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    rawData?: SortOrder
    processed?: SortOrder
    propertyHash?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    source_sourceId?: PropertyRecordSourceSourceIdCompoundUniqueInput
    AND?: PropertyRecordWhereInput | PropertyRecordWhereInput[]
    OR?: PropertyRecordWhereInput[]
    NOT?: PropertyRecordWhereInput | PropertyRecordWhereInput[]
    source?: StringFilter<"PropertyRecord"> | string
    sourceId?: StringNullableFilter<"PropertyRecord"> | string | null
    address?: StringFilter<"PropertyRecord"> | string
    city?: StringFilter<"PropertyRecord"> | string
    state?: StringFilter<"PropertyRecord"> | string
    zipCode?: StringFilter<"PropertyRecord"> | string
    rawData?: StringFilter<"PropertyRecord"> | string
    processed?: BoolFilter<"PropertyRecord"> | boolean
    propertyHash?: StringFilter<"PropertyRecord"> | string
    createdAt?: DateTimeFilter<"PropertyRecord"> | Date | string
  }, "id" | "source_sourceId">

  export type PropertyRecordOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    rawData?: SortOrder
    processed?: SortOrder
    propertyHash?: SortOrder
    createdAt?: SortOrder
    _count?: PropertyRecordCountOrderByAggregateInput
    _max?: PropertyRecordMaxOrderByAggregateInput
    _min?: PropertyRecordMinOrderByAggregateInput
  }

  export type PropertyRecordScalarWhereWithAggregatesInput = {
    AND?: PropertyRecordScalarWhereWithAggregatesInput | PropertyRecordScalarWhereWithAggregatesInput[]
    OR?: PropertyRecordScalarWhereWithAggregatesInput[]
    NOT?: PropertyRecordScalarWhereWithAggregatesInput | PropertyRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyRecord"> | string
    source?: StringWithAggregatesFilter<"PropertyRecord"> | string
    sourceId?: StringNullableWithAggregatesFilter<"PropertyRecord"> | string | null
    address?: StringWithAggregatesFilter<"PropertyRecord"> | string
    city?: StringWithAggregatesFilter<"PropertyRecord"> | string
    state?: StringWithAggregatesFilter<"PropertyRecord"> | string
    zipCode?: StringWithAggregatesFilter<"PropertyRecord"> | string
    rawData?: StringWithAggregatesFilter<"PropertyRecord"> | string
    processed?: BoolWithAggregatesFilter<"PropertyRecord"> | boolean
    propertyHash?: StringWithAggregatesFilter<"PropertyRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyRecord"> | Date | string
  }

  export type DailyMetricWhereInput = {
    AND?: DailyMetricWhereInput | DailyMetricWhereInput[]
    OR?: DailyMetricWhereInput[]
    NOT?: DailyMetricWhereInput | DailyMetricWhereInput[]
    id?: StringFilter<"DailyMetric"> | string
    date?: DateTimeFilter<"DailyMetric"> | Date | string
    leadsGenerated?: IntFilter<"DailyMetric"> | number
    leadsContacted?: IntFilter<"DailyMetric"> | number
    leadsConverted?: IntFilter<"DailyMetric"> | number
    campaignsSent?: IntFilter<"DailyMetric"> | number
    campaignReplies?: IntFilter<"DailyMetric"> | number
    callsMade?: IntFilter<"DailyMetric"> | number
    callsAnswered?: IntFilter<"DailyMetric"> | number
    avgCallDuration?: FloatNullableFilter<"DailyMetric"> | number | null
    skipTracesRun?: IntFilter<"DailyMetric"> | number
    skipTraceSuccess?: IntFilter<"DailyMetric"> | number
    totalSpent?: FloatFilter<"DailyMetric"> | number
    revenueGenerated?: FloatFilter<"DailyMetric"> | number
    createdAt?: DateTimeFilter<"DailyMetric"> | Date | string
  }

  export type DailyMetricOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    leadsGenerated?: SortOrder
    leadsContacted?: SortOrder
    leadsConverted?: SortOrder
    campaignsSent?: SortOrder
    campaignReplies?: SortOrder
    callsMade?: SortOrder
    callsAnswered?: SortOrder
    avgCallDuration?: SortOrderInput | SortOrder
    skipTracesRun?: SortOrder
    skipTraceSuccess?: SortOrder
    totalSpent?: SortOrder
    revenueGenerated?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    AND?: DailyMetricWhereInput | DailyMetricWhereInput[]
    OR?: DailyMetricWhereInput[]
    NOT?: DailyMetricWhereInput | DailyMetricWhereInput[]
    leadsGenerated?: IntFilter<"DailyMetric"> | number
    leadsContacted?: IntFilter<"DailyMetric"> | number
    leadsConverted?: IntFilter<"DailyMetric"> | number
    campaignsSent?: IntFilter<"DailyMetric"> | number
    campaignReplies?: IntFilter<"DailyMetric"> | number
    callsMade?: IntFilter<"DailyMetric"> | number
    callsAnswered?: IntFilter<"DailyMetric"> | number
    avgCallDuration?: FloatNullableFilter<"DailyMetric"> | number | null
    skipTracesRun?: IntFilter<"DailyMetric"> | number
    skipTraceSuccess?: IntFilter<"DailyMetric"> | number
    totalSpent?: FloatFilter<"DailyMetric"> | number
    revenueGenerated?: FloatFilter<"DailyMetric"> | number
    createdAt?: DateTimeFilter<"DailyMetric"> | Date | string
  }, "id" | "date">

  export type DailyMetricOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    leadsGenerated?: SortOrder
    leadsContacted?: SortOrder
    leadsConverted?: SortOrder
    campaignsSent?: SortOrder
    campaignReplies?: SortOrder
    callsMade?: SortOrder
    callsAnswered?: SortOrder
    avgCallDuration?: SortOrderInput | SortOrder
    skipTracesRun?: SortOrder
    skipTraceSuccess?: SortOrder
    totalSpent?: SortOrder
    revenueGenerated?: SortOrder
    createdAt?: SortOrder
    _count?: DailyMetricCountOrderByAggregateInput
    _avg?: DailyMetricAvgOrderByAggregateInput
    _max?: DailyMetricMaxOrderByAggregateInput
    _min?: DailyMetricMinOrderByAggregateInput
    _sum?: DailyMetricSumOrderByAggregateInput
  }

  export type DailyMetricScalarWhereWithAggregatesInput = {
    AND?: DailyMetricScalarWhereWithAggregatesInput | DailyMetricScalarWhereWithAggregatesInput[]
    OR?: DailyMetricScalarWhereWithAggregatesInput[]
    NOT?: DailyMetricScalarWhereWithAggregatesInput | DailyMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyMetric"> | string
    date?: DateTimeWithAggregatesFilter<"DailyMetric"> | Date | string
    leadsGenerated?: IntWithAggregatesFilter<"DailyMetric"> | number
    leadsContacted?: IntWithAggregatesFilter<"DailyMetric"> | number
    leadsConverted?: IntWithAggregatesFilter<"DailyMetric"> | number
    campaignsSent?: IntWithAggregatesFilter<"DailyMetric"> | number
    campaignReplies?: IntWithAggregatesFilter<"DailyMetric"> | number
    callsMade?: IntWithAggregatesFilter<"DailyMetric"> | number
    callsAnswered?: IntWithAggregatesFilter<"DailyMetric"> | number
    avgCallDuration?: FloatNullableWithAggregatesFilter<"DailyMetric"> | number | null
    skipTracesRun?: IntWithAggregatesFilter<"DailyMetric"> | number
    skipTraceSuccess?: IntWithAggregatesFilter<"DailyMetric"> | number
    totalSpent?: FloatWithAggregatesFilter<"DailyMetric"> | number
    revenueGenerated?: FloatWithAggregatesFilter<"DailyMetric"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DailyMetric"> | Date | string
  }

  export type ScraperJobWhereInput = {
    AND?: ScraperJobWhereInput | ScraperJobWhereInput[]
    OR?: ScraperJobWhereInput[]
    NOT?: ScraperJobWhereInput | ScraperJobWhereInput[]
    id?: StringFilter<"ScraperJob"> | string
    source?: EnumScraperSourceFilter<"ScraperJob"> | $Enums.ScraperSource
    inputPayload?: JsonFilter<"ScraperJob">
    resultPayload?: JsonNullableFilter<"ScraperJob">
    status?: EnumJobStatusFilter<"ScraperJob"> | $Enums.JobStatus
    startedAt?: DateTimeNullableFilter<"ScraperJob"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"ScraperJob"> | Date | string | null
    error?: StringNullableFilter<"ScraperJob"> | string | null
    createdAt?: DateTimeFilter<"ScraperJob"> | Date | string
    updatedAt?: DateTimeFilter<"ScraperJob"> | Date | string
  }

  export type ScraperJobOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    inputPayload?: SortOrder
    resultPayload?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScraperJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScraperJobWhereInput | ScraperJobWhereInput[]
    OR?: ScraperJobWhereInput[]
    NOT?: ScraperJobWhereInput | ScraperJobWhereInput[]
    source?: EnumScraperSourceFilter<"ScraperJob"> | $Enums.ScraperSource
    inputPayload?: JsonFilter<"ScraperJob">
    resultPayload?: JsonNullableFilter<"ScraperJob">
    status?: EnumJobStatusFilter<"ScraperJob"> | $Enums.JobStatus
    startedAt?: DateTimeNullableFilter<"ScraperJob"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"ScraperJob"> | Date | string | null
    error?: StringNullableFilter<"ScraperJob"> | string | null
    createdAt?: DateTimeFilter<"ScraperJob"> | Date | string
    updatedAt?: DateTimeFilter<"ScraperJob"> | Date | string
  }, "id">

  export type ScraperJobOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    inputPayload?: SortOrder
    resultPayload?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScraperJobCountOrderByAggregateInput
    _max?: ScraperJobMaxOrderByAggregateInput
    _min?: ScraperJobMinOrderByAggregateInput
  }

  export type ScraperJobScalarWhereWithAggregatesInput = {
    AND?: ScraperJobScalarWhereWithAggregatesInput | ScraperJobScalarWhereWithAggregatesInput[]
    OR?: ScraperJobScalarWhereWithAggregatesInput[]
    NOT?: ScraperJobScalarWhereWithAggregatesInput | ScraperJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScraperJob"> | string
    source?: EnumScraperSourceWithAggregatesFilter<"ScraperJob"> | $Enums.ScraperSource
    inputPayload?: JsonWithAggregatesFilter<"ScraperJob">
    resultPayload?: JsonNullableWithAggregatesFilter<"ScraperJob">
    status?: EnumJobStatusWithAggregatesFilter<"ScraperJob"> | $Enums.JobStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"ScraperJob"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"ScraperJob"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"ScraperJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScraperJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScraperJob"> | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    users?: UserCreateNestedManyWithoutOrganizationInput
    leads?: LeadCreateNestedManyWithoutOrganizationInput
    campaigns?: CampaignCreateNestedManyWithoutOrganizationInput
    callLogs?: CallLogCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrganizationInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOrganizationInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutOrganizationNestedInput
    leads?: LeadUpdateManyWithoutOrganizationNestedInput
    campaigns?: CampaignUpdateManyWithoutOrganizationNestedInput
    callLogs?: CallLogUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrganizationNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOrganizationNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    callLogs?: CallLogCreateNestedManyWithoutCreatedByInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutCreatedByInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    callLogs?: CallLogUpdateManyWithoutCreatedByNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutCreatedByNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCreateInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organization: OrganizationCreateNestedOneWithoutLeadsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    callLogs?: CallLogCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organizationId: string
    assignedToId?: string | null
    callLogs?: CallLogUncheckedCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteUncheckedCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutLeadsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    callLogs?: CallLogUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    callLogs?: CallLogUncheckedUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUncheckedUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organizationId: string
    assignedToId?: string | null
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadNoteCreateInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
    lead: LeadCreateNestedOneWithoutLeadNotesInput
  }

  export type LeadNoteUncheckedCreateInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
    leadId: string
  }

  export type LeadNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutLeadNotesNestedInput
  }

  export type LeadNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadNoteCreateManyInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
    leadId: string
  }

  export type LeadNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type SkipTraceRecordCreateInput = {
    id?: string
    provider: string
    status: string
    requestData: string
    responseData?: string | null
    cost?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    lead: LeadCreateNestedOneWithoutSkipTraceRecordsInput
  }

  export type SkipTraceRecordUncheckedCreateInput = {
    id?: string
    provider: string
    status: string
    requestData: string
    responseData?: string | null
    cost?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    leadId: string
  }

  export type SkipTraceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: StringFieldUpdateOperationsInput | string
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lead?: LeadUpdateOneRequiredWithoutSkipTraceRecordsNestedInput
  }

  export type SkipTraceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: StringFieldUpdateOperationsInput | string
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type SkipTraceRecordCreateManyInput = {
    id?: string
    provider: string
    status: string
    requestData: string
    responseData?: string | null
    cost?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    leadId: string
  }

  export type SkipTraceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: StringFieldUpdateOperationsInput | string
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkipTraceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: StringFieldUpdateOperationsInput | string
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    subject?: string | null
    message: string
    script?: string | null
    filters: string
    targetCount?: number
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sent?: number
    delivered?: number
    opened?: number
    clicked?: number
    replied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutCampaignsInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    subject?: string | null
    message: string
    script?: string | null
    filters: string
    targetCount?: number
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sent?: number
    delivered?: number
    opened?: number
    clicked?: number
    replied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutCampaignsNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    type: string
    status?: string
    subject?: string | null
    message: string
    script?: string | null
    filters: string
    targetCount?: number
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sent?: number
    delivered?: number
    opened?: number
    clicked?: number
    replied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignLogCreateInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutCampaignLogsInput
    lead: LeadCreateNestedOneWithoutCampaignLogsInput
    user?: UserCreateNestedOneWithoutCampaignLogsInput
  }

  export type CampaignLogUncheckedCreateInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaignId: string
    leadId: string
    userId?: string | null
  }

  export type CampaignLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutCampaignLogsNestedInput
    lead?: LeadUpdateOneRequiredWithoutCampaignLogsNestedInput
    user?: UserUpdateOneWithoutCampaignLogsNestedInput
  }

  export type CampaignLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignLogCreateManyInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaignId: string
    leadId: string
    userId?: string | null
  }

  export type CampaignLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CallLogCreateInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    lead: LeadCreateNestedOneWithoutCallLogsInput
    organization: OrganizationCreateNestedOneWithoutCallLogsInput
    createdBy: UserCreateNestedOneWithoutCallLogsInput
  }

  export type CallLogUncheckedCreateInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    leadId: string
    organizationId: string
    createdById: string
  }

  export type CallLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutCallLogsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutCallLogsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCallLogsNestedInput
  }

  export type CallLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type CallLogCreateManyInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    leadId: string
    organizationId: string
    createdById: string
  }

  export type CallLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ScrapingJobCreateInput = {
    id?: string
    source: string
    status: string
    config: string
    recordsFound?: number
    recordsSaved?: number
    errorCount?: number
    logs?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ScrapingJobUncheckedCreateInput = {
    id?: string
    source: string
    status: string
    config: string
    recordsFound?: number
    recordsSaved?: number
    errorCount?: number
    logs?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ScrapingJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    recordsFound?: IntFieldUpdateOperationsInput | number
    recordsSaved?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScrapingJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    recordsFound?: IntFieldUpdateOperationsInput | number
    recordsSaved?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScrapingJobCreateManyInput = {
    id?: string
    source: string
    status: string
    config: string
    recordsFound?: number
    recordsSaved?: number
    errorCount?: number
    logs?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ScrapingJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    recordsFound?: IntFieldUpdateOperationsInput | number
    recordsSaved?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScrapingJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    recordsFound?: IntFieldUpdateOperationsInput | number
    recordsSaved?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    logs?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyRecordCreateInput = {
    id?: string
    source: string
    sourceId?: string | null
    address: string
    city: string
    state: string
    zipCode: string
    rawData: string
    processed?: boolean
    propertyHash: string
    createdAt?: Date | string
  }

  export type PropertyRecordUncheckedCreateInput = {
    id?: string
    source: string
    sourceId?: string | null
    address: string
    city: string
    state: string
    zipCode: string
    rawData: string
    processed?: boolean
    propertyHash: string
    createdAt?: Date | string
  }

  export type PropertyRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    rawData?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    propertyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    rawData?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    propertyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyRecordCreateManyInput = {
    id?: string
    source: string
    sourceId?: string | null
    address: string
    city: string
    state: string
    zipCode: string
    rawData: string
    processed?: boolean
    propertyHash: string
    createdAt?: Date | string
  }

  export type PropertyRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    rawData?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    propertyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    rawData?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    propertyHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyMetricCreateInput = {
    id?: string
    date: Date | string
    leadsGenerated?: number
    leadsContacted?: number
    leadsConverted?: number
    campaignsSent?: number
    campaignReplies?: number
    callsMade?: number
    callsAnswered?: number
    avgCallDuration?: number | null
    skipTracesRun?: number
    skipTraceSuccess?: number
    totalSpent?: number
    revenueGenerated?: number
    createdAt?: Date | string
  }

  export type DailyMetricUncheckedCreateInput = {
    id?: string
    date: Date | string
    leadsGenerated?: number
    leadsContacted?: number
    leadsConverted?: number
    campaignsSent?: number
    campaignReplies?: number
    callsMade?: number
    callsAnswered?: number
    avgCallDuration?: number | null
    skipTracesRun?: number
    skipTraceSuccess?: number
    totalSpent?: number
    revenueGenerated?: number
    createdAt?: Date | string
  }

  export type DailyMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    leadsGenerated?: IntFieldUpdateOperationsInput | number
    leadsContacted?: IntFieldUpdateOperationsInput | number
    leadsConverted?: IntFieldUpdateOperationsInput | number
    campaignsSent?: IntFieldUpdateOperationsInput | number
    campaignReplies?: IntFieldUpdateOperationsInput | number
    callsMade?: IntFieldUpdateOperationsInput | number
    callsAnswered?: IntFieldUpdateOperationsInput | number
    avgCallDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    skipTracesRun?: IntFieldUpdateOperationsInput | number
    skipTraceSuccess?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    leadsGenerated?: IntFieldUpdateOperationsInput | number
    leadsContacted?: IntFieldUpdateOperationsInput | number
    leadsConverted?: IntFieldUpdateOperationsInput | number
    campaignsSent?: IntFieldUpdateOperationsInput | number
    campaignReplies?: IntFieldUpdateOperationsInput | number
    callsMade?: IntFieldUpdateOperationsInput | number
    callsAnswered?: IntFieldUpdateOperationsInput | number
    avgCallDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    skipTracesRun?: IntFieldUpdateOperationsInput | number
    skipTraceSuccess?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyMetricCreateManyInput = {
    id?: string
    date: Date | string
    leadsGenerated?: number
    leadsContacted?: number
    leadsConverted?: number
    campaignsSent?: number
    campaignReplies?: number
    callsMade?: number
    callsAnswered?: number
    avgCallDuration?: number | null
    skipTracesRun?: number
    skipTraceSuccess?: number
    totalSpent?: number
    revenueGenerated?: number
    createdAt?: Date | string
  }

  export type DailyMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    leadsGenerated?: IntFieldUpdateOperationsInput | number
    leadsContacted?: IntFieldUpdateOperationsInput | number
    leadsConverted?: IntFieldUpdateOperationsInput | number
    campaignsSent?: IntFieldUpdateOperationsInput | number
    campaignReplies?: IntFieldUpdateOperationsInput | number
    callsMade?: IntFieldUpdateOperationsInput | number
    callsAnswered?: IntFieldUpdateOperationsInput | number
    avgCallDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    skipTracesRun?: IntFieldUpdateOperationsInput | number
    skipTraceSuccess?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    leadsGenerated?: IntFieldUpdateOperationsInput | number
    leadsContacted?: IntFieldUpdateOperationsInput | number
    leadsConverted?: IntFieldUpdateOperationsInput | number
    campaignsSent?: IntFieldUpdateOperationsInput | number
    campaignReplies?: IntFieldUpdateOperationsInput | number
    callsMade?: IntFieldUpdateOperationsInput | number
    callsAnswered?: IntFieldUpdateOperationsInput | number
    avgCallDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    skipTracesRun?: IntFieldUpdateOperationsInput | number
    skipTraceSuccess?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScraperJobCreateInput = {
    id?: string
    source: $Enums.ScraperSource
    inputPayload: JsonNullValueInput | InputJsonValue
    resultPayload?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.JobStatus
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScraperJobUncheckedCreateInput = {
    id?: string
    source: $Enums.ScraperSource
    inputPayload: JsonNullValueInput | InputJsonValue
    resultPayload?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.JobStatus
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScraperJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumScraperSourceFieldUpdateOperationsInput | $Enums.ScraperSource
    inputPayload?: JsonNullValueInput | InputJsonValue
    resultPayload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScraperJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumScraperSourceFieldUpdateOperationsInput | $Enums.ScraperSource
    inputPayload?: JsonNullValueInput | InputJsonValue
    resultPayload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScraperJobCreateManyInput = {
    id?: string
    source: $Enums.ScraperSource
    inputPayload: JsonNullValueInput | InputJsonValue
    resultPayload?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.JobStatus
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScraperJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumScraperSourceFieldUpdateOperationsInput | $Enums.ScraperSource
    inputPayload?: JsonNullValueInput | InputJsonValue
    resultPayload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScraperJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumScraperSourceFieldUpdateOperationsInput | $Enums.ScraperSource
    inputPayload?: JsonNullValueInput | InputJsonValue
    resultPayload?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CallLogListRelationFilter = {
    every?: CallLogWhereInput
    some?: CallLogWhereInput
    none?: CallLogWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    monthlyLeadCount?: SortOrder
    monthlySkipTraceCount?: SortOrder
    monthlyCampaignCount?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    monthlyLeadCount?: SortOrder
    monthlySkipTraceCount?: SortOrder
    monthlyCampaignCount?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    monthlyLeadCount?: SortOrder
    monthlySkipTraceCount?: SortOrder
    monthlyCampaignCount?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    monthlyLeadCount?: SortOrder
    monthlySkipTraceCount?: SortOrder
    monthlyCampaignCount?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    monthlyLeadCount?: SortOrder
    monthlySkipTraceCount?: SortOrder
    monthlyCampaignCount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type CampaignLogListRelationFilter = {
    every?: CampaignLogWhereInput
    some?: CampaignLogWhereInput
    none?: CampaignLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CampaignLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LeadNoteListRelationFilter = {
    every?: LeadNoteWhereInput
    some?: LeadNoteWhereInput
    none?: LeadNoteWhereInput
  }

  export type SkipTraceRecordListRelationFilter = {
    every?: SkipTraceRecordWhereInput
    some?: SkipTraceRecordWhereInput
    none?: SkipTraceRecordWhereInput
  }

  export type LeadNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkipTraceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    source?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    propertyType?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFootage?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    normalizedAddress?: SortOrder
    listPrice?: SortOrder
    arv?: SortOrder
    estimatedValue?: SortOrder
    estimatedRepairs?: SortOrder
    marketValue?: SortOrder
    loanAmount?: SortOrder
    equity?: SortOrder
    equityPercent?: SortOrder
    lastSalePrice?: SortOrder
    lastSaleDate?: SortOrder
    taxAssessedValue?: SortOrder
    ownerName?: SortOrder
    ownerPhone?: SortOrder
    ownerEmail?: SortOrder
    ownerAddress?: SortOrder
    isAbsenteeOwner?: SortOrder
    phonesJson?: SortOrder
    emailsJson?: SortOrder
    skipTraceProvider?: SortOrder
    skipTraceCostCents?: SortOrder
    skipTracedAt?: SortOrder
    dncFlag?: SortOrder
    motivationScore?: SortOrder
    motivationFactors?: SortOrder
    distressSignals?: SortOrder
    timeOnMarket?: SortOrder
    priceReductions?: SortOrder
    aiScore?: SortOrder
    aiCostCents?: SortOrder
    aiScoredAt?: SortOrder
    aiSummary?: SortOrder
    dealPotential?: SortOrder
    profitEstimate?: SortOrder
    temperatureTag?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    assignedToId?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFootage?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    listPrice?: SortOrder
    arv?: SortOrder
    estimatedValue?: SortOrder
    estimatedRepairs?: SortOrder
    marketValue?: SortOrder
    loanAmount?: SortOrder
    equity?: SortOrder
    equityPercent?: SortOrder
    lastSalePrice?: SortOrder
    taxAssessedValue?: SortOrder
    skipTraceCostCents?: SortOrder
    motivationScore?: SortOrder
    timeOnMarket?: SortOrder
    priceReductions?: SortOrder
    aiScore?: SortOrder
    aiCostCents?: SortOrder
    profitEstimate?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    source?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    propertyType?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFootage?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    normalizedAddress?: SortOrder
    listPrice?: SortOrder
    arv?: SortOrder
    estimatedValue?: SortOrder
    estimatedRepairs?: SortOrder
    marketValue?: SortOrder
    loanAmount?: SortOrder
    equity?: SortOrder
    equityPercent?: SortOrder
    lastSalePrice?: SortOrder
    lastSaleDate?: SortOrder
    taxAssessedValue?: SortOrder
    ownerName?: SortOrder
    ownerPhone?: SortOrder
    ownerEmail?: SortOrder
    ownerAddress?: SortOrder
    isAbsenteeOwner?: SortOrder
    phonesJson?: SortOrder
    emailsJson?: SortOrder
    skipTraceProvider?: SortOrder
    skipTraceCostCents?: SortOrder
    skipTracedAt?: SortOrder
    dncFlag?: SortOrder
    motivationScore?: SortOrder
    motivationFactors?: SortOrder
    distressSignals?: SortOrder
    timeOnMarket?: SortOrder
    priceReductions?: SortOrder
    aiScore?: SortOrder
    aiCostCents?: SortOrder
    aiScoredAt?: SortOrder
    aiSummary?: SortOrder
    dealPotential?: SortOrder
    profitEstimate?: SortOrder
    temperatureTag?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    assignedToId?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    source?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    propertyType?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFootage?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    normalizedAddress?: SortOrder
    listPrice?: SortOrder
    arv?: SortOrder
    estimatedValue?: SortOrder
    estimatedRepairs?: SortOrder
    marketValue?: SortOrder
    loanAmount?: SortOrder
    equity?: SortOrder
    equityPercent?: SortOrder
    lastSalePrice?: SortOrder
    lastSaleDate?: SortOrder
    taxAssessedValue?: SortOrder
    ownerName?: SortOrder
    ownerPhone?: SortOrder
    ownerEmail?: SortOrder
    ownerAddress?: SortOrder
    isAbsenteeOwner?: SortOrder
    phonesJson?: SortOrder
    emailsJson?: SortOrder
    skipTraceProvider?: SortOrder
    skipTraceCostCents?: SortOrder
    skipTracedAt?: SortOrder
    dncFlag?: SortOrder
    motivationScore?: SortOrder
    motivationFactors?: SortOrder
    distressSignals?: SortOrder
    timeOnMarket?: SortOrder
    priceReductions?: SortOrder
    aiScore?: SortOrder
    aiCostCents?: SortOrder
    aiScoredAt?: SortOrder
    aiSummary?: SortOrder
    dealPotential?: SortOrder
    profitEstimate?: SortOrder
    temperatureTag?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    organizationId?: SortOrder
    assignedToId?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFootage?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    listPrice?: SortOrder
    arv?: SortOrder
    estimatedValue?: SortOrder
    estimatedRepairs?: SortOrder
    marketValue?: SortOrder
    loanAmount?: SortOrder
    equity?: SortOrder
    equityPercent?: SortOrder
    lastSalePrice?: SortOrder
    taxAssessedValue?: SortOrder
    skipTraceCostCents?: SortOrder
    motivationScore?: SortOrder
    timeOnMarket?: SortOrder
    priceReductions?: SortOrder
    aiScore?: SortOrder
    aiCostCents?: SortOrder
    profitEstimate?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type LeadRelationFilter = {
    is?: LeadWhereInput
    isNot?: LeadWhereInput
  }

  export type LeadNoteCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
  }

  export type LeadNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
  }

  export type LeadNoteMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
  }

  export type SkipTraceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    cost?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    leadId?: SortOrder
  }

  export type SkipTraceRecordAvgOrderByAggregateInput = {
    cost?: SortOrder
    confidence?: SortOrder
  }

  export type SkipTraceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    cost?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    leadId?: SortOrder
  }

  export type SkipTraceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    cost?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    leadId?: SortOrder
  }

  export type SkipTraceRecordSumOrderByAggregateInput = {
    cost?: SortOrder
    confidence?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    script?: SortOrder
    filters?: SortOrder
    targetCount?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    sent?: SortOrder
    delivered?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    replied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    targetCount?: SortOrder
    sent?: SortOrder
    delivered?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    replied?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    script?: SortOrder
    filters?: SortOrder
    targetCount?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    sent?: SortOrder
    delivered?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    replied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    script?: SortOrder
    filters?: SortOrder
    targetCount?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    sent?: SortOrder
    delivered?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    replied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    targetCount?: SortOrder
    sent?: SortOrder
    delivered?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    replied?: SortOrder
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignLogCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    response?: SortOrder
    errorMessage?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    repliedAt?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    userId?: SortOrder
  }

  export type CampaignLogMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    response?: SortOrder
    errorMessage?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    repliedAt?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    userId?: SortOrder
  }

  export type CampaignLogMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    response?: SortOrder
    errorMessage?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    repliedAt?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    userId?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CallLogCountOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    transcript?: SortOrder
    recording?: SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    twilioCallSid?: SortOrder
    sentiment?: SortOrder
    aiSummary?: SortOrder
    motivationScore?: SortOrder
    outcome?: SortOrder
    followUpDate?: SortOrder
    callStartedAt?: SortOrder
    callEndedAt?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    organizationId?: SortOrder
    createdById?: SortOrder
  }

  export type CallLogAvgOrderByAggregateInput = {
    duration?: SortOrder
    motivationScore?: SortOrder
  }

  export type CallLogMaxOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    transcript?: SortOrder
    recording?: SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    twilioCallSid?: SortOrder
    sentiment?: SortOrder
    aiSummary?: SortOrder
    motivationScore?: SortOrder
    outcome?: SortOrder
    followUpDate?: SortOrder
    callStartedAt?: SortOrder
    callEndedAt?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    organizationId?: SortOrder
    createdById?: SortOrder
  }

  export type CallLogMinOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    transcript?: SortOrder
    recording?: SortOrder
    fromNumber?: SortOrder
    toNumber?: SortOrder
    twilioCallSid?: SortOrder
    sentiment?: SortOrder
    aiSummary?: SortOrder
    motivationScore?: SortOrder
    outcome?: SortOrder
    followUpDate?: SortOrder
    callStartedAt?: SortOrder
    callEndedAt?: SortOrder
    createdAt?: SortOrder
    leadId?: SortOrder
    organizationId?: SortOrder
    createdById?: SortOrder
  }

  export type CallLogSumOrderByAggregateInput = {
    duration?: SortOrder
    motivationScore?: SortOrder
  }

  export type ScrapingJobCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    status?: SortOrder
    config?: SortOrder
    recordsFound?: SortOrder
    recordsSaved?: SortOrder
    errorCount?: SortOrder
    logs?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ScrapingJobAvgOrderByAggregateInput = {
    recordsFound?: SortOrder
    recordsSaved?: SortOrder
    errorCount?: SortOrder
  }

  export type ScrapingJobMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    status?: SortOrder
    config?: SortOrder
    recordsFound?: SortOrder
    recordsSaved?: SortOrder
    errorCount?: SortOrder
    logs?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ScrapingJobMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    status?: SortOrder
    config?: SortOrder
    recordsFound?: SortOrder
    recordsSaved?: SortOrder
    errorCount?: SortOrder
    logs?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ScrapingJobSumOrderByAggregateInput = {
    recordsFound?: SortOrder
    recordsSaved?: SortOrder
    errorCount?: SortOrder
  }

  export type PropertyRecordSourceSourceIdCompoundUniqueInput = {
    source: string
    sourceId: string
  }

  export type PropertyRecordCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    rawData?: SortOrder
    processed?: SortOrder
    propertyHash?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    rawData?: SortOrder
    processed?: SortOrder
    propertyHash?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyRecordMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    rawData?: SortOrder
    processed?: SortOrder
    propertyHash?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DailyMetricCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    leadsGenerated?: SortOrder
    leadsContacted?: SortOrder
    leadsConverted?: SortOrder
    campaignsSent?: SortOrder
    campaignReplies?: SortOrder
    callsMade?: SortOrder
    callsAnswered?: SortOrder
    avgCallDuration?: SortOrder
    skipTracesRun?: SortOrder
    skipTraceSuccess?: SortOrder
    totalSpent?: SortOrder
    revenueGenerated?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyMetricAvgOrderByAggregateInput = {
    leadsGenerated?: SortOrder
    leadsContacted?: SortOrder
    leadsConverted?: SortOrder
    campaignsSent?: SortOrder
    campaignReplies?: SortOrder
    callsMade?: SortOrder
    callsAnswered?: SortOrder
    avgCallDuration?: SortOrder
    skipTracesRun?: SortOrder
    skipTraceSuccess?: SortOrder
    totalSpent?: SortOrder
    revenueGenerated?: SortOrder
  }

  export type DailyMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    leadsGenerated?: SortOrder
    leadsContacted?: SortOrder
    leadsConverted?: SortOrder
    campaignsSent?: SortOrder
    campaignReplies?: SortOrder
    callsMade?: SortOrder
    callsAnswered?: SortOrder
    avgCallDuration?: SortOrder
    skipTracesRun?: SortOrder
    skipTraceSuccess?: SortOrder
    totalSpent?: SortOrder
    revenueGenerated?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyMetricMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    leadsGenerated?: SortOrder
    leadsContacted?: SortOrder
    leadsConverted?: SortOrder
    campaignsSent?: SortOrder
    campaignReplies?: SortOrder
    callsMade?: SortOrder
    callsAnswered?: SortOrder
    avgCallDuration?: SortOrder
    skipTracesRun?: SortOrder
    skipTraceSuccess?: SortOrder
    totalSpent?: SortOrder
    revenueGenerated?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyMetricSumOrderByAggregateInput = {
    leadsGenerated?: SortOrder
    leadsContacted?: SortOrder
    leadsConverted?: SortOrder
    campaignsSent?: SortOrder
    campaignReplies?: SortOrder
    callsMade?: SortOrder
    callsAnswered?: SortOrder
    avgCallDuration?: SortOrder
    skipTracesRun?: SortOrder
    skipTraceSuccess?: SortOrder
    totalSpent?: SortOrder
    revenueGenerated?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumScraperSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ScraperSource | EnumScraperSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ScraperSource[] | ListEnumScraperSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScraperSource[] | ListEnumScraperSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumScraperSourceFilter<$PrismaModel> | $Enums.ScraperSource
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type ScraperJobCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    inputPayload?: SortOrder
    resultPayload?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScraperJobMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScraperJobMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumScraperSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScraperSource | EnumScraperSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ScraperSource[] | ListEnumScraperSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScraperSource[] | ListEnumScraperSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumScraperSourceWithAggregatesFilter<$PrismaModel> | $Enums.ScraperSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScraperSourceFilter<$PrismaModel>
    _max?: NestedEnumScraperSourceFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LeadCreateWithoutOrganizationInput, LeadUncheckedCreateWithoutOrganizationInput> | LeadCreateWithoutOrganizationInput[] | LeadUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOrganizationInput | LeadCreateOrConnectWithoutOrganizationInput[]
    createMany?: LeadCreateManyOrganizationInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CampaignCreateWithoutOrganizationInput, CampaignUncheckedCreateWithoutOrganizationInput> | CampaignCreateWithoutOrganizationInput[] | CampaignUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutOrganizationInput | CampaignCreateOrConnectWithoutOrganizationInput[]
    createMany?: CampaignCreateManyOrganizationInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CallLogCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CallLogCreateWithoutOrganizationInput, CallLogUncheckedCreateWithoutOrganizationInput> | CallLogCreateWithoutOrganizationInput[] | CallLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutOrganizationInput | CallLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: CallLogCreateManyOrganizationInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LeadCreateWithoutOrganizationInput, LeadUncheckedCreateWithoutOrganizationInput> | LeadCreateWithoutOrganizationInput[] | LeadUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOrganizationInput | LeadCreateOrConnectWithoutOrganizationInput[]
    createMany?: LeadCreateManyOrganizationInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CampaignCreateWithoutOrganizationInput, CampaignUncheckedCreateWithoutOrganizationInput> | CampaignCreateWithoutOrganizationInput[] | CampaignUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutOrganizationInput | CampaignCreateOrConnectWithoutOrganizationInput[]
    createMany?: CampaignCreateManyOrganizationInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CallLogUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CallLogCreateWithoutOrganizationInput, CallLogUncheckedCreateWithoutOrganizationInput> | CallLogCreateWithoutOrganizationInput[] | CallLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutOrganizationInput | CallLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: CallLogCreateManyOrganizationInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LeadCreateWithoutOrganizationInput, LeadUncheckedCreateWithoutOrganizationInput> | LeadCreateWithoutOrganizationInput[] | LeadUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOrganizationInput | LeadCreateOrConnectWithoutOrganizationInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOrganizationInput | LeadUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LeadCreateManyOrganizationInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOrganizationInput | LeadUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOrganizationInput | LeadUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CampaignCreateWithoutOrganizationInput, CampaignUncheckedCreateWithoutOrganizationInput> | CampaignCreateWithoutOrganizationInput[] | CampaignUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutOrganizationInput | CampaignCreateOrConnectWithoutOrganizationInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutOrganizationInput | CampaignUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CampaignCreateManyOrganizationInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutOrganizationInput | CampaignUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutOrganizationInput | CampaignUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CallLogUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CallLogCreateWithoutOrganizationInput, CallLogUncheckedCreateWithoutOrganizationInput> | CallLogCreateWithoutOrganizationInput[] | CallLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutOrganizationInput | CallLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutOrganizationInput | CallLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CallLogCreateManyOrganizationInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutOrganizationInput | CallLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutOrganizationInput | CallLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LeadCreateWithoutOrganizationInput, LeadUncheckedCreateWithoutOrganizationInput> | LeadCreateWithoutOrganizationInput[] | LeadUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutOrganizationInput | LeadCreateOrConnectWithoutOrganizationInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutOrganizationInput | LeadUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LeadCreateManyOrganizationInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutOrganizationInput | LeadUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutOrganizationInput | LeadUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CampaignCreateWithoutOrganizationInput, CampaignUncheckedCreateWithoutOrganizationInput> | CampaignCreateWithoutOrganizationInput[] | CampaignUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutOrganizationInput | CampaignCreateOrConnectWithoutOrganizationInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutOrganizationInput | CampaignUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CampaignCreateManyOrganizationInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutOrganizationInput | CampaignUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutOrganizationInput | CampaignUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CallLogUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CallLogCreateWithoutOrganizationInput, CallLogUncheckedCreateWithoutOrganizationInput> | CallLogCreateWithoutOrganizationInput[] | CallLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutOrganizationInput | CallLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutOrganizationInput | CallLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CallLogCreateManyOrganizationInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutOrganizationInput | CallLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutOrganizationInput | CallLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type LeadCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput> | LeadCreateWithoutAssignedToInput[] | LeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAssignedToInput | LeadCreateOrConnectWithoutAssignedToInput[]
    createMany?: LeadCreateManyAssignedToInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CallLogCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CallLogCreateWithoutCreatedByInput, CallLogUncheckedCreateWithoutCreatedByInput> | CallLogCreateWithoutCreatedByInput[] | CallLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutCreatedByInput | CallLogCreateOrConnectWithoutCreatedByInput[]
    createMany?: CallLogCreateManyCreatedByInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type CampaignLogCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignLogCreateWithoutUserInput, CampaignLogUncheckedCreateWithoutUserInput> | CampaignLogCreateWithoutUserInput[] | CampaignLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutUserInput | CampaignLogCreateOrConnectWithoutUserInput[]
    createMany?: CampaignLogCreateManyUserInputEnvelope
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput> | LeadCreateWithoutAssignedToInput[] | LeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAssignedToInput | LeadCreateOrConnectWithoutAssignedToInput[]
    createMany?: LeadCreateManyAssignedToInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CallLogUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CallLogCreateWithoutCreatedByInput, CallLogUncheckedCreateWithoutCreatedByInput> | CallLogCreateWithoutCreatedByInput[] | CallLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutCreatedByInput | CallLogCreateOrConnectWithoutCreatedByInput[]
    createMany?: CallLogCreateManyCreatedByInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type CampaignLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignLogCreateWithoutUserInput, CampaignLogUncheckedCreateWithoutUserInput> | CampaignLogCreateWithoutUserInput[] | CampaignLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutUserInput | CampaignLogCreateOrConnectWithoutUserInput[]
    createMany?: CampaignLogCreateManyUserInputEnvelope
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type LeadUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput> | LeadCreateWithoutAssignedToInput[] | LeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAssignedToInput | LeadCreateOrConnectWithoutAssignedToInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutAssignedToInput | LeadUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: LeadCreateManyAssignedToInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutAssignedToInput | LeadUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutAssignedToInput | LeadUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type CallLogUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CallLogCreateWithoutCreatedByInput, CallLogUncheckedCreateWithoutCreatedByInput> | CallLogCreateWithoutCreatedByInput[] | CallLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutCreatedByInput | CallLogCreateOrConnectWithoutCreatedByInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutCreatedByInput | CallLogUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CallLogCreateManyCreatedByInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutCreatedByInput | CallLogUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutCreatedByInput | CallLogUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type CampaignLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignLogCreateWithoutUserInput, CampaignLogUncheckedCreateWithoutUserInput> | CampaignLogCreateWithoutUserInput[] | CampaignLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutUserInput | CampaignLogCreateOrConnectWithoutUserInput[]
    upsert?: CampaignLogUpsertWithWhereUniqueWithoutUserInput | CampaignLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignLogCreateManyUserInputEnvelope
    set?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    disconnect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    delete?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    update?: CampaignLogUpdateWithWhereUniqueWithoutUserInput | CampaignLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignLogUpdateManyWithWhereWithoutUserInput | CampaignLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput> | LeadCreateWithoutAssignedToInput[] | LeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAssignedToInput | LeadCreateOrConnectWithoutAssignedToInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutAssignedToInput | LeadUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: LeadCreateManyAssignedToInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutAssignedToInput | LeadUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutAssignedToInput | LeadUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type CallLogUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CallLogCreateWithoutCreatedByInput, CallLogUncheckedCreateWithoutCreatedByInput> | CallLogCreateWithoutCreatedByInput[] | CallLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutCreatedByInput | CallLogCreateOrConnectWithoutCreatedByInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutCreatedByInput | CallLogUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CallLogCreateManyCreatedByInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutCreatedByInput | CallLogUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutCreatedByInput | CallLogUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type CampaignLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignLogCreateWithoutUserInput, CampaignLogUncheckedCreateWithoutUserInput> | CampaignLogCreateWithoutUserInput[] | CampaignLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutUserInput | CampaignLogCreateOrConnectWithoutUserInput[]
    upsert?: CampaignLogUpsertWithWhereUniqueWithoutUserInput | CampaignLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignLogCreateManyUserInputEnvelope
    set?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    disconnect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    delete?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    update?: CampaignLogUpdateWithWhereUniqueWithoutUserInput | CampaignLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignLogUpdateManyWithWhereWithoutUserInput | CampaignLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutLeadsInput = {
    create?: XOR<OrganizationCreateWithoutLeadsInput, OrganizationUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLeadsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedLeadsInput = {
    create?: XOR<UserCreateWithoutAssignedLeadsInput, UserUncheckedCreateWithoutAssignedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type CallLogCreateNestedManyWithoutLeadInput = {
    create?: XOR<CallLogCreateWithoutLeadInput, CallLogUncheckedCreateWithoutLeadInput> | CallLogCreateWithoutLeadInput[] | CallLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutLeadInput | CallLogCreateOrConnectWithoutLeadInput[]
    createMany?: CallLogCreateManyLeadInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type CampaignLogCreateNestedManyWithoutLeadInput = {
    create?: XOR<CampaignLogCreateWithoutLeadInput, CampaignLogUncheckedCreateWithoutLeadInput> | CampaignLogCreateWithoutLeadInput[] | CampaignLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutLeadInput | CampaignLogCreateOrConnectWithoutLeadInput[]
    createMany?: CampaignLogCreateManyLeadInputEnvelope
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
  }

  export type LeadNoteCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadNoteCreateWithoutLeadInput, LeadNoteUncheckedCreateWithoutLeadInput> | LeadNoteCreateWithoutLeadInput[] | LeadNoteUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadNoteCreateOrConnectWithoutLeadInput | LeadNoteCreateOrConnectWithoutLeadInput[]
    createMany?: LeadNoteCreateManyLeadInputEnvelope
    connect?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
  }

  export type SkipTraceRecordCreateNestedManyWithoutLeadInput = {
    create?: XOR<SkipTraceRecordCreateWithoutLeadInput, SkipTraceRecordUncheckedCreateWithoutLeadInput> | SkipTraceRecordCreateWithoutLeadInput[] | SkipTraceRecordUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: SkipTraceRecordCreateOrConnectWithoutLeadInput | SkipTraceRecordCreateOrConnectWithoutLeadInput[]
    createMany?: SkipTraceRecordCreateManyLeadInputEnvelope
    connect?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
  }

  export type CallLogUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<CallLogCreateWithoutLeadInput, CallLogUncheckedCreateWithoutLeadInput> | CallLogCreateWithoutLeadInput[] | CallLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutLeadInput | CallLogCreateOrConnectWithoutLeadInput[]
    createMany?: CallLogCreateManyLeadInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type CampaignLogUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<CampaignLogCreateWithoutLeadInput, CampaignLogUncheckedCreateWithoutLeadInput> | CampaignLogCreateWithoutLeadInput[] | CampaignLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutLeadInput | CampaignLogCreateOrConnectWithoutLeadInput[]
    createMany?: CampaignLogCreateManyLeadInputEnvelope
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
  }

  export type LeadNoteUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadNoteCreateWithoutLeadInput, LeadNoteUncheckedCreateWithoutLeadInput> | LeadNoteCreateWithoutLeadInput[] | LeadNoteUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadNoteCreateOrConnectWithoutLeadInput | LeadNoteCreateOrConnectWithoutLeadInput[]
    createMany?: LeadNoteCreateManyLeadInputEnvelope
    connect?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
  }

  export type SkipTraceRecordUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<SkipTraceRecordCreateWithoutLeadInput, SkipTraceRecordUncheckedCreateWithoutLeadInput> | SkipTraceRecordCreateWithoutLeadInput[] | SkipTraceRecordUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: SkipTraceRecordCreateOrConnectWithoutLeadInput | SkipTraceRecordCreateOrConnectWithoutLeadInput[]
    createMany?: SkipTraceRecordCreateManyLeadInputEnvelope
    connect?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<OrganizationCreateWithoutLeadsInput, OrganizationUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLeadsInput
    upsert?: OrganizationUpsertWithoutLeadsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutLeadsInput, OrganizationUpdateWithoutLeadsInput>, OrganizationUncheckedUpdateWithoutLeadsInput>
  }

  export type UserUpdateOneWithoutAssignedLeadsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedLeadsInput, UserUncheckedCreateWithoutAssignedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedLeadsInput
    upsert?: UserUpsertWithoutAssignedLeadsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedLeadsInput, UserUpdateWithoutAssignedLeadsInput>, UserUncheckedUpdateWithoutAssignedLeadsInput>
  }

  export type CallLogUpdateManyWithoutLeadNestedInput = {
    create?: XOR<CallLogCreateWithoutLeadInput, CallLogUncheckedCreateWithoutLeadInput> | CallLogCreateWithoutLeadInput[] | CallLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutLeadInput | CallLogCreateOrConnectWithoutLeadInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutLeadInput | CallLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: CallLogCreateManyLeadInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutLeadInput | CallLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutLeadInput | CallLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type CampaignLogUpdateManyWithoutLeadNestedInput = {
    create?: XOR<CampaignLogCreateWithoutLeadInput, CampaignLogUncheckedCreateWithoutLeadInput> | CampaignLogCreateWithoutLeadInput[] | CampaignLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutLeadInput | CampaignLogCreateOrConnectWithoutLeadInput[]
    upsert?: CampaignLogUpsertWithWhereUniqueWithoutLeadInput | CampaignLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: CampaignLogCreateManyLeadInputEnvelope
    set?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    disconnect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    delete?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    update?: CampaignLogUpdateWithWhereUniqueWithoutLeadInput | CampaignLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: CampaignLogUpdateManyWithWhereWithoutLeadInput | CampaignLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
  }

  export type LeadNoteUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadNoteCreateWithoutLeadInput, LeadNoteUncheckedCreateWithoutLeadInput> | LeadNoteCreateWithoutLeadInput[] | LeadNoteUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadNoteCreateOrConnectWithoutLeadInput | LeadNoteCreateOrConnectWithoutLeadInput[]
    upsert?: LeadNoteUpsertWithWhereUniqueWithoutLeadInput | LeadNoteUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadNoteCreateManyLeadInputEnvelope
    set?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
    disconnect?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
    delete?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
    connect?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
    update?: LeadNoteUpdateWithWhereUniqueWithoutLeadInput | LeadNoteUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadNoteUpdateManyWithWhereWithoutLeadInput | LeadNoteUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadNoteScalarWhereInput | LeadNoteScalarWhereInput[]
  }

  export type SkipTraceRecordUpdateManyWithoutLeadNestedInput = {
    create?: XOR<SkipTraceRecordCreateWithoutLeadInput, SkipTraceRecordUncheckedCreateWithoutLeadInput> | SkipTraceRecordCreateWithoutLeadInput[] | SkipTraceRecordUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: SkipTraceRecordCreateOrConnectWithoutLeadInput | SkipTraceRecordCreateOrConnectWithoutLeadInput[]
    upsert?: SkipTraceRecordUpsertWithWhereUniqueWithoutLeadInput | SkipTraceRecordUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: SkipTraceRecordCreateManyLeadInputEnvelope
    set?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
    disconnect?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
    delete?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
    connect?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
    update?: SkipTraceRecordUpdateWithWhereUniqueWithoutLeadInput | SkipTraceRecordUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: SkipTraceRecordUpdateManyWithWhereWithoutLeadInput | SkipTraceRecordUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: SkipTraceRecordScalarWhereInput | SkipTraceRecordScalarWhereInput[]
  }

  export type CallLogUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<CallLogCreateWithoutLeadInput, CallLogUncheckedCreateWithoutLeadInput> | CallLogCreateWithoutLeadInput[] | CallLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutLeadInput | CallLogCreateOrConnectWithoutLeadInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutLeadInput | CallLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: CallLogCreateManyLeadInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutLeadInput | CallLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutLeadInput | CallLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type CampaignLogUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<CampaignLogCreateWithoutLeadInput, CampaignLogUncheckedCreateWithoutLeadInput> | CampaignLogCreateWithoutLeadInput[] | CampaignLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutLeadInput | CampaignLogCreateOrConnectWithoutLeadInput[]
    upsert?: CampaignLogUpsertWithWhereUniqueWithoutLeadInput | CampaignLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: CampaignLogCreateManyLeadInputEnvelope
    set?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    disconnect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    delete?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    update?: CampaignLogUpdateWithWhereUniqueWithoutLeadInput | CampaignLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: CampaignLogUpdateManyWithWhereWithoutLeadInput | CampaignLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
  }

  export type LeadNoteUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadNoteCreateWithoutLeadInput, LeadNoteUncheckedCreateWithoutLeadInput> | LeadNoteCreateWithoutLeadInput[] | LeadNoteUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadNoteCreateOrConnectWithoutLeadInput | LeadNoteCreateOrConnectWithoutLeadInput[]
    upsert?: LeadNoteUpsertWithWhereUniqueWithoutLeadInput | LeadNoteUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadNoteCreateManyLeadInputEnvelope
    set?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
    disconnect?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
    delete?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
    connect?: LeadNoteWhereUniqueInput | LeadNoteWhereUniqueInput[]
    update?: LeadNoteUpdateWithWhereUniqueWithoutLeadInput | LeadNoteUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadNoteUpdateManyWithWhereWithoutLeadInput | LeadNoteUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadNoteScalarWhereInput | LeadNoteScalarWhereInput[]
  }

  export type SkipTraceRecordUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<SkipTraceRecordCreateWithoutLeadInput, SkipTraceRecordUncheckedCreateWithoutLeadInput> | SkipTraceRecordCreateWithoutLeadInput[] | SkipTraceRecordUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: SkipTraceRecordCreateOrConnectWithoutLeadInput | SkipTraceRecordCreateOrConnectWithoutLeadInput[]
    upsert?: SkipTraceRecordUpsertWithWhereUniqueWithoutLeadInput | SkipTraceRecordUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: SkipTraceRecordCreateManyLeadInputEnvelope
    set?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
    disconnect?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
    delete?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
    connect?: SkipTraceRecordWhereUniqueInput | SkipTraceRecordWhereUniqueInput[]
    update?: SkipTraceRecordUpdateWithWhereUniqueWithoutLeadInput | SkipTraceRecordUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: SkipTraceRecordUpdateManyWithWhereWithoutLeadInput | SkipTraceRecordUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: SkipTraceRecordScalarWhereInput | SkipTraceRecordScalarWhereInput[]
  }

  export type LeadCreateNestedOneWithoutLeadNotesInput = {
    create?: XOR<LeadCreateWithoutLeadNotesInput, LeadUncheckedCreateWithoutLeadNotesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutLeadNotesInput
    connect?: LeadWhereUniqueInput
  }

  export type LeadUpdateOneRequiredWithoutLeadNotesNestedInput = {
    create?: XOR<LeadCreateWithoutLeadNotesInput, LeadUncheckedCreateWithoutLeadNotesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutLeadNotesInput
    upsert?: LeadUpsertWithoutLeadNotesInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutLeadNotesInput, LeadUpdateWithoutLeadNotesInput>, LeadUncheckedUpdateWithoutLeadNotesInput>
  }

  export type LeadCreateNestedOneWithoutSkipTraceRecordsInput = {
    create?: XOR<LeadCreateWithoutSkipTraceRecordsInput, LeadUncheckedCreateWithoutSkipTraceRecordsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutSkipTraceRecordsInput
    connect?: LeadWhereUniqueInput
  }

  export type LeadUpdateOneRequiredWithoutSkipTraceRecordsNestedInput = {
    create?: XOR<LeadCreateWithoutSkipTraceRecordsInput, LeadUncheckedCreateWithoutSkipTraceRecordsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutSkipTraceRecordsInput
    upsert?: LeadUpsertWithoutSkipTraceRecordsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutSkipTraceRecordsInput, LeadUpdateWithoutSkipTraceRecordsInput>, LeadUncheckedUpdateWithoutSkipTraceRecordsInput>
  }

  export type OrganizationCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<OrganizationCreateWithoutCampaignsInput, OrganizationUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCampaignsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CampaignLogCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput> | CampaignLogCreateWithoutCampaignInput[] | CampaignLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutCampaignInput | CampaignLogCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLogCreateManyCampaignInputEnvelope
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
  }

  export type CampaignLogUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput> | CampaignLogCreateWithoutCampaignInput[] | CampaignLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutCampaignInput | CampaignLogCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLogCreateManyCampaignInputEnvelope
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<OrganizationCreateWithoutCampaignsInput, OrganizationUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCampaignsInput
    upsert?: OrganizationUpsertWithoutCampaignsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCampaignsInput, OrganizationUpdateWithoutCampaignsInput>, OrganizationUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignLogUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput> | CampaignLogCreateWithoutCampaignInput[] | CampaignLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutCampaignInput | CampaignLogCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLogUpsertWithWhereUniqueWithoutCampaignInput | CampaignLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLogCreateManyCampaignInputEnvelope
    set?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    disconnect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    delete?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    update?: CampaignLogUpdateWithWhereUniqueWithoutCampaignInput | CampaignLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLogUpdateManyWithWhereWithoutCampaignInput | CampaignLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
  }

  export type CampaignLogUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput> | CampaignLogCreateWithoutCampaignInput[] | CampaignLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutCampaignInput | CampaignLogCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLogUpsertWithWhereUniqueWithoutCampaignInput | CampaignLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLogCreateManyCampaignInputEnvelope
    set?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    disconnect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    delete?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    update?: CampaignLogUpdateWithWhereUniqueWithoutCampaignInput | CampaignLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLogUpdateManyWithWhereWithoutCampaignInput | CampaignLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutCampaignLogsInput = {
    create?: XOR<CampaignCreateWithoutCampaignLogsInput, CampaignUncheckedCreateWithoutCampaignLogsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignLogsInput
    connect?: CampaignWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutCampaignLogsInput = {
    create?: XOR<LeadCreateWithoutCampaignLogsInput, LeadUncheckedCreateWithoutCampaignLogsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCampaignLogsInput
    connect?: LeadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCampaignLogsInput = {
    create?: XOR<UserCreateWithoutCampaignLogsInput, UserUncheckedCreateWithoutCampaignLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCampaignLogsNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaignLogsInput, CampaignUncheckedCreateWithoutCampaignLogsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignLogsInput
    upsert?: CampaignUpsertWithoutCampaignLogsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCampaignLogsInput, CampaignUpdateWithoutCampaignLogsInput>, CampaignUncheckedUpdateWithoutCampaignLogsInput>
  }

  export type LeadUpdateOneRequiredWithoutCampaignLogsNestedInput = {
    create?: XOR<LeadCreateWithoutCampaignLogsInput, LeadUncheckedCreateWithoutCampaignLogsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCampaignLogsInput
    upsert?: LeadUpsertWithoutCampaignLogsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutCampaignLogsInput, LeadUpdateWithoutCampaignLogsInput>, LeadUncheckedUpdateWithoutCampaignLogsInput>
  }

  export type UserUpdateOneWithoutCampaignLogsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignLogsInput, UserUncheckedCreateWithoutCampaignLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignLogsInput
    upsert?: UserUpsertWithoutCampaignLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignLogsInput, UserUpdateWithoutCampaignLogsInput>, UserUncheckedUpdateWithoutCampaignLogsInput>
  }

  export type LeadCreateNestedOneWithoutCallLogsInput = {
    create?: XOR<LeadCreateWithoutCallLogsInput, LeadUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCallLogsInput
    connect?: LeadWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutCallLogsInput = {
    create?: XOR<OrganizationCreateWithoutCallLogsInput, OrganizationUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCallLogsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCallLogsInput = {
    create?: XOR<UserCreateWithoutCallLogsInput, UserUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCallLogsInput
    connect?: UserWhereUniqueInput
  }

  export type LeadUpdateOneRequiredWithoutCallLogsNestedInput = {
    create?: XOR<LeadCreateWithoutCallLogsInput, LeadUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCallLogsInput
    upsert?: LeadUpsertWithoutCallLogsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutCallLogsInput, LeadUpdateWithoutCallLogsInput>, LeadUncheckedUpdateWithoutCallLogsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutCallLogsNestedInput = {
    create?: XOR<OrganizationCreateWithoutCallLogsInput, OrganizationUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCallLogsInput
    upsert?: OrganizationUpsertWithoutCallLogsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCallLogsInput, OrganizationUpdateWithoutCallLogsInput>, OrganizationUncheckedUpdateWithoutCallLogsInput>
  }

  export type UserUpdateOneRequiredWithoutCallLogsNestedInput = {
    create?: XOR<UserCreateWithoutCallLogsInput, UserUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCallLogsInput
    upsert?: UserUpsertWithoutCallLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCallLogsInput, UserUpdateWithoutCallLogsInput>, UserUncheckedUpdateWithoutCallLogsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumScraperSourceFieldUpdateOperationsInput = {
    set?: $Enums.ScraperSource
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumScraperSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ScraperSource | EnumScraperSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ScraperSource[] | ListEnumScraperSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScraperSource[] | ListEnumScraperSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumScraperSourceFilter<$PrismaModel> | $Enums.ScraperSource
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumScraperSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScraperSource | EnumScraperSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ScraperSource[] | ListEnumScraperSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScraperSource[] | ListEnumScraperSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumScraperSourceWithAggregatesFilter<$PrismaModel> | $Enums.ScraperSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScraperSourceFilter<$PrismaModel>
    _max?: NestedEnumScraperSourceFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    callLogs?: CallLogCreateNestedManyWithoutCreatedByInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutCreatedByInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutOrganizationInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    callLogs?: CallLogCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutOrganizationInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    assignedToId?: string | null
    callLogs?: CallLogUncheckedCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteUncheckedCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutOrganizationInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutOrganizationInput, LeadUncheckedCreateWithoutOrganizationInput>
  }

  export type LeadCreateManyOrganizationInputEnvelope = {
    data: LeadCreateManyOrganizationInput | LeadCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutOrganizationInput = {
    id?: string
    name: string
    type: string
    status?: string
    subject?: string | null
    message: string
    script?: string | null
    filters: string
    targetCount?: number
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sent?: number
    delivered?: number
    opened?: number
    clicked?: number
    replied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignLogs?: CampaignLogCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    type: string
    status?: string
    subject?: string | null
    message: string
    script?: string | null
    filters: string
    targetCount?: number
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sent?: number
    delivered?: number
    opened?: number
    clicked?: number
    replied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutOrganizationInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutOrganizationInput, CampaignUncheckedCreateWithoutOrganizationInput>
  }

  export type CampaignCreateManyOrganizationInputEnvelope = {
    data: CampaignCreateManyOrganizationInput | CampaignCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CallLogCreateWithoutOrganizationInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    lead: LeadCreateNestedOneWithoutCallLogsInput
    createdBy: UserCreateNestedOneWithoutCallLogsInput
  }

  export type CallLogUncheckedCreateWithoutOrganizationInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    leadId: string
    createdById: string
  }

  export type CallLogCreateOrConnectWithoutOrganizationInput = {
    where: CallLogWhereUniqueInput
    create: XOR<CallLogCreateWithoutOrganizationInput, CallLogUncheckedCreateWithoutOrganizationInput>
  }

  export type CallLogCreateManyOrganizationInputEnvelope = {
    data: CallLogCreateManyOrganizationInput | CallLogCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organizationId?: StringFilter<"User"> | string
  }

  export type LeadUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutOrganizationInput, LeadUncheckedUpdateWithoutOrganizationInput>
    create: XOR<LeadCreateWithoutOrganizationInput, LeadUncheckedCreateWithoutOrganizationInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutOrganizationInput, LeadUncheckedUpdateWithoutOrganizationInput>
  }

  export type LeadUpdateManyWithWhereWithoutOrganizationInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    status?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    priority?: StringFilter<"Lead"> | string
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    propertyAddress?: StringFilter<"Lead"> | string
    city?: StringFilter<"Lead"> | string
    state?: StringFilter<"Lead"> | string
    zipCode?: StringFilter<"Lead"> | string
    propertyType?: StringNullableFilter<"Lead"> | string | null
    bedrooms?: IntNullableFilter<"Lead"> | number | null
    bathrooms?: FloatNullableFilter<"Lead"> | number | null
    squareFootage?: IntNullableFilter<"Lead"> | number | null
    lotSize?: FloatNullableFilter<"Lead"> | number | null
    yearBuilt?: IntNullableFilter<"Lead"> | number | null
    normalizedAddress?: StringNullableFilter<"Lead"> | string | null
    listPrice?: FloatNullableFilter<"Lead"> | number | null
    arv?: FloatNullableFilter<"Lead"> | number | null
    estimatedValue?: IntNullableFilter<"Lead"> | number | null
    estimatedRepairs?: FloatNullableFilter<"Lead"> | number | null
    marketValue?: FloatNullableFilter<"Lead"> | number | null
    loanAmount?: FloatNullableFilter<"Lead"> | number | null
    equity?: IntNullableFilter<"Lead"> | number | null
    equityPercent?: FloatNullableFilter<"Lead"> | number | null
    lastSalePrice?: FloatNullableFilter<"Lead"> | number | null
    lastSaleDate?: DateTimeNullableFilter<"Lead"> | Date | string | null
    taxAssessedValue?: FloatNullableFilter<"Lead"> | number | null
    ownerName?: StringNullableFilter<"Lead"> | string | null
    ownerPhone?: StringNullableFilter<"Lead"> | string | null
    ownerEmail?: StringNullableFilter<"Lead"> | string | null
    ownerAddress?: StringNullableFilter<"Lead"> | string | null
    isAbsenteeOwner?: BoolFilter<"Lead"> | boolean
    phonesJson?: StringNullableFilter<"Lead"> | string | null
    emailsJson?: StringNullableFilter<"Lead"> | string | null
    skipTraceProvider?: StringNullableFilter<"Lead"> | string | null
    skipTraceCostCents?: IntNullableFilter<"Lead"> | number | null
    skipTracedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    dncFlag?: BoolFilter<"Lead"> | boolean
    motivationScore?: FloatNullableFilter<"Lead"> | number | null
    motivationFactors?: StringNullableFilter<"Lead"> | string | null
    distressSignals?: StringNullableFilter<"Lead"> | string | null
    timeOnMarket?: IntNullableFilter<"Lead"> | number | null
    priceReductions?: IntNullableFilter<"Lead"> | number | null
    aiScore?: IntNullableFilter<"Lead"> | number | null
    aiCostCents?: IntNullableFilter<"Lead"> | number | null
    aiScoredAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    aiSummary?: StringNullableFilter<"Lead"> | string | null
    dealPotential?: StringNullableFilter<"Lead"> | string | null
    profitEstimate?: FloatNullableFilter<"Lead"> | number | null
    temperatureTag?: StringNullableFilter<"Lead"> | string | null
    tags?: StringFilter<"Lead"> | string
    isActive?: BoolFilter<"Lead"> | boolean
    organizationId?: StringFilter<"Lead"> | string
    assignedToId?: StringNullableFilter<"Lead"> | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutOrganizationInput, CampaignUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CampaignCreateWithoutOrganizationInput, CampaignUncheckedCreateWithoutOrganizationInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutOrganizationInput, CampaignUncheckedUpdateWithoutOrganizationInput>
  }

  export type CampaignUpdateManyWithWhereWithoutOrganizationInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    subject?: StringNullableFilter<"Campaign"> | string | null
    message?: StringFilter<"Campaign"> | string
    script?: StringNullableFilter<"Campaign"> | string | null
    filters?: StringFilter<"Campaign"> | string
    targetCount?: IntFilter<"Campaign"> | number
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sent?: IntFilter<"Campaign"> | number
    delivered?: IntFilter<"Campaign"> | number
    opened?: IntFilter<"Campaign"> | number
    clicked?: IntFilter<"Campaign"> | number
    replied?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    organizationId?: StringFilter<"Campaign"> | string
  }

  export type CallLogUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CallLogWhereUniqueInput
    update: XOR<CallLogUpdateWithoutOrganizationInput, CallLogUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CallLogCreateWithoutOrganizationInput, CallLogUncheckedCreateWithoutOrganizationInput>
  }

  export type CallLogUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CallLogWhereUniqueInput
    data: XOR<CallLogUpdateWithoutOrganizationInput, CallLogUncheckedUpdateWithoutOrganizationInput>
  }

  export type CallLogUpdateManyWithWhereWithoutOrganizationInput = {
    where: CallLogScalarWhereInput
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CallLogScalarWhereInput = {
    AND?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
    OR?: CallLogScalarWhereInput[]
    NOT?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
    id?: StringFilter<"CallLog"> | string
    direction?: StringFilter<"CallLog"> | string
    status?: StringFilter<"CallLog"> | string
    duration?: IntNullableFilter<"CallLog"> | number | null
    transcript?: StringNullableFilter<"CallLog"> | string | null
    recording?: StringNullableFilter<"CallLog"> | string | null
    fromNumber?: StringFilter<"CallLog"> | string
    toNumber?: StringFilter<"CallLog"> | string
    twilioCallSid?: StringNullableFilter<"CallLog"> | string | null
    sentiment?: StringNullableFilter<"CallLog"> | string | null
    aiSummary?: StringNullableFilter<"CallLog"> | string | null
    motivationScore?: FloatNullableFilter<"CallLog"> | number | null
    outcome?: StringNullableFilter<"CallLog"> | string | null
    followUpDate?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    callStartedAt?: DateTimeFilter<"CallLog"> | Date | string
    callEndedAt?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    createdAt?: DateTimeFilter<"CallLog"> | Date | string
    leadId?: StringFilter<"CallLog"> | string
    organizationId?: StringFilter<"CallLog"> | string
    createdById?: StringFilter<"CallLog"> | string
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    leads?: LeadCreateNestedManyWithoutOrganizationInput
    campaigns?: CampaignCreateNestedManyWithoutOrganizationInput
    callLogs?: CallLogCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    leads?: LeadUncheckedCreateNestedManyWithoutOrganizationInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOrganizationInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type LeadCreateWithoutAssignedToInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organization: OrganizationCreateNestedOneWithoutLeadsInput
    callLogs?: CallLogCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutAssignedToInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organizationId: string
    callLogs?: CallLogUncheckedCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteUncheckedCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutAssignedToInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput>
  }

  export type LeadCreateManyAssignedToInputEnvelope = {
    data: LeadCreateManyAssignedToInput | LeadCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type CallLogCreateWithoutCreatedByInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    lead: LeadCreateNestedOneWithoutCallLogsInput
    organization: OrganizationCreateNestedOneWithoutCallLogsInput
  }

  export type CallLogUncheckedCreateWithoutCreatedByInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    leadId: string
    organizationId: string
  }

  export type CallLogCreateOrConnectWithoutCreatedByInput = {
    where: CallLogWhereUniqueInput
    create: XOR<CallLogCreateWithoutCreatedByInput, CallLogUncheckedCreateWithoutCreatedByInput>
  }

  export type CallLogCreateManyCreatedByInputEnvelope = {
    data: CallLogCreateManyCreatedByInput | CallLogCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CampaignLogCreateWithoutUserInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutCampaignLogsInput
    lead: LeadCreateNestedOneWithoutCampaignLogsInput
  }

  export type CampaignLogUncheckedCreateWithoutUserInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaignId: string
    leadId: string
  }

  export type CampaignLogCreateOrConnectWithoutUserInput = {
    where: CampaignLogWhereUniqueInput
    create: XOR<CampaignLogCreateWithoutUserInput, CampaignLogUncheckedCreateWithoutUserInput>
  }

  export type CampaignLogCreateManyUserInputEnvelope = {
    data: CampaignLogCreateManyUserInput | CampaignLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    leads?: LeadUpdateManyWithoutOrganizationNestedInput
    campaigns?: CampaignUpdateManyWithoutOrganizationNestedInput
    callLogs?: CallLogUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    leads?: LeadUncheckedUpdateManyWithoutOrganizationNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOrganizationNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type LeadUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutAssignedToInput, LeadUncheckedUpdateWithoutAssignedToInput>
    create: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutAssignedToInput, LeadUncheckedUpdateWithoutAssignedToInput>
  }

  export type LeadUpdateManyWithWhereWithoutAssignedToInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type CallLogUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CallLogWhereUniqueInput
    update: XOR<CallLogUpdateWithoutCreatedByInput, CallLogUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CallLogCreateWithoutCreatedByInput, CallLogUncheckedCreateWithoutCreatedByInput>
  }

  export type CallLogUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CallLogWhereUniqueInput
    data: XOR<CallLogUpdateWithoutCreatedByInput, CallLogUncheckedUpdateWithoutCreatedByInput>
  }

  export type CallLogUpdateManyWithWhereWithoutCreatedByInput = {
    where: CallLogScalarWhereInput
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CampaignLogUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignLogWhereUniqueInput
    update: XOR<CampaignLogUpdateWithoutUserInput, CampaignLogUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignLogCreateWithoutUserInput, CampaignLogUncheckedCreateWithoutUserInput>
  }

  export type CampaignLogUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignLogWhereUniqueInput
    data: XOR<CampaignLogUpdateWithoutUserInput, CampaignLogUncheckedUpdateWithoutUserInput>
  }

  export type CampaignLogUpdateManyWithWhereWithoutUserInput = {
    where: CampaignLogScalarWhereInput
    data: XOR<CampaignLogUpdateManyMutationInput, CampaignLogUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignLogScalarWhereInput = {
    AND?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
    OR?: CampaignLogScalarWhereInput[]
    NOT?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
    id?: StringFilter<"CampaignLog"> | string
    status?: StringFilter<"CampaignLog"> | string
    response?: StringNullableFilter<"CampaignLog"> | string | null
    errorMessage?: StringNullableFilter<"CampaignLog"> | string | null
    sentAt?: DateTimeFilter<"CampaignLog"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    repliedAt?: DateTimeNullableFilter<"CampaignLog"> | Date | string | null
    campaignId?: StringFilter<"CampaignLog"> | string
    leadId?: StringFilter<"CampaignLog"> | string
    userId?: StringNullableFilter<"CampaignLog"> | string | null
  }

  export type OrganizationCreateWithoutLeadsInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    users?: UserCreateNestedManyWithoutOrganizationInput
    campaigns?: CampaignCreateNestedManyWithoutOrganizationInput
    callLogs?: CallLogCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOrganizationInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutLeadsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutLeadsInput, OrganizationUncheckedCreateWithoutLeadsInput>
  }

  export type UserCreateWithoutAssignedLeadsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    callLogs?: CallLogCreateNestedManyWithoutCreatedByInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedLeadsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    callLogs?: CallLogUncheckedCreateNestedManyWithoutCreatedByInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedLeadsInput, UserUncheckedCreateWithoutAssignedLeadsInput>
  }

  export type CallLogCreateWithoutLeadInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutCallLogsInput
    createdBy: UserCreateNestedOneWithoutCallLogsInput
  }

  export type CallLogUncheckedCreateWithoutLeadInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    organizationId: string
    createdById: string
  }

  export type CallLogCreateOrConnectWithoutLeadInput = {
    where: CallLogWhereUniqueInput
    create: XOR<CallLogCreateWithoutLeadInput, CallLogUncheckedCreateWithoutLeadInput>
  }

  export type CallLogCreateManyLeadInputEnvelope = {
    data: CallLogCreateManyLeadInput | CallLogCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type CampaignLogCreateWithoutLeadInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutCampaignLogsInput
    user?: UserCreateNestedOneWithoutCampaignLogsInput
  }

  export type CampaignLogUncheckedCreateWithoutLeadInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaignId: string
    userId?: string | null
  }

  export type CampaignLogCreateOrConnectWithoutLeadInput = {
    where: CampaignLogWhereUniqueInput
    create: XOR<CampaignLogCreateWithoutLeadInput, CampaignLogUncheckedCreateWithoutLeadInput>
  }

  export type CampaignLogCreateManyLeadInputEnvelope = {
    data: CampaignLogCreateManyLeadInput | CampaignLogCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type LeadNoteCreateWithoutLeadInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
  }

  export type LeadNoteUncheckedCreateWithoutLeadInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
  }

  export type LeadNoteCreateOrConnectWithoutLeadInput = {
    where: LeadNoteWhereUniqueInput
    create: XOR<LeadNoteCreateWithoutLeadInput, LeadNoteUncheckedCreateWithoutLeadInput>
  }

  export type LeadNoteCreateManyLeadInputEnvelope = {
    data: LeadNoteCreateManyLeadInput | LeadNoteCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type SkipTraceRecordCreateWithoutLeadInput = {
    id?: string
    provider: string
    status: string
    requestData: string
    responseData?: string | null
    cost?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SkipTraceRecordUncheckedCreateWithoutLeadInput = {
    id?: string
    provider: string
    status: string
    requestData: string
    responseData?: string | null
    cost?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SkipTraceRecordCreateOrConnectWithoutLeadInput = {
    where: SkipTraceRecordWhereUniqueInput
    create: XOR<SkipTraceRecordCreateWithoutLeadInput, SkipTraceRecordUncheckedCreateWithoutLeadInput>
  }

  export type SkipTraceRecordCreateManyLeadInputEnvelope = {
    data: SkipTraceRecordCreateManyLeadInput | SkipTraceRecordCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutLeadsInput = {
    update: XOR<OrganizationUpdateWithoutLeadsInput, OrganizationUncheckedUpdateWithoutLeadsInput>
    create: XOR<OrganizationCreateWithoutLeadsInput, OrganizationUncheckedCreateWithoutLeadsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutLeadsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutLeadsInput, OrganizationUncheckedUpdateWithoutLeadsInput>
  }

  export type OrganizationUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutOrganizationNestedInput
    campaigns?: CampaignUpdateManyWithoutOrganizationNestedInput
    callLogs?: CallLogUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOrganizationNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutAssignedLeadsInput = {
    update: XOR<UserUpdateWithoutAssignedLeadsInput, UserUncheckedUpdateWithoutAssignedLeadsInput>
    create: XOR<UserCreateWithoutAssignedLeadsInput, UserUncheckedCreateWithoutAssignedLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedLeadsInput, UserUncheckedUpdateWithoutAssignedLeadsInput>
  }

  export type UserUpdateWithoutAssignedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    callLogs?: CallLogUpdateManyWithoutCreatedByNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    callLogs?: CallLogUncheckedUpdateManyWithoutCreatedByNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CallLogUpsertWithWhereUniqueWithoutLeadInput = {
    where: CallLogWhereUniqueInput
    update: XOR<CallLogUpdateWithoutLeadInput, CallLogUncheckedUpdateWithoutLeadInput>
    create: XOR<CallLogCreateWithoutLeadInput, CallLogUncheckedCreateWithoutLeadInput>
  }

  export type CallLogUpdateWithWhereUniqueWithoutLeadInput = {
    where: CallLogWhereUniqueInput
    data: XOR<CallLogUpdateWithoutLeadInput, CallLogUncheckedUpdateWithoutLeadInput>
  }

  export type CallLogUpdateManyWithWhereWithoutLeadInput = {
    where: CallLogScalarWhereInput
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyWithoutLeadInput>
  }

  export type CampaignLogUpsertWithWhereUniqueWithoutLeadInput = {
    where: CampaignLogWhereUniqueInput
    update: XOR<CampaignLogUpdateWithoutLeadInput, CampaignLogUncheckedUpdateWithoutLeadInput>
    create: XOR<CampaignLogCreateWithoutLeadInput, CampaignLogUncheckedCreateWithoutLeadInput>
  }

  export type CampaignLogUpdateWithWhereUniqueWithoutLeadInput = {
    where: CampaignLogWhereUniqueInput
    data: XOR<CampaignLogUpdateWithoutLeadInput, CampaignLogUncheckedUpdateWithoutLeadInput>
  }

  export type CampaignLogUpdateManyWithWhereWithoutLeadInput = {
    where: CampaignLogScalarWhereInput
    data: XOR<CampaignLogUpdateManyMutationInput, CampaignLogUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadNoteUpsertWithWhereUniqueWithoutLeadInput = {
    where: LeadNoteWhereUniqueInput
    update: XOR<LeadNoteUpdateWithoutLeadInput, LeadNoteUncheckedUpdateWithoutLeadInput>
    create: XOR<LeadNoteCreateWithoutLeadInput, LeadNoteUncheckedCreateWithoutLeadInput>
  }

  export type LeadNoteUpdateWithWhereUniqueWithoutLeadInput = {
    where: LeadNoteWhereUniqueInput
    data: XOR<LeadNoteUpdateWithoutLeadInput, LeadNoteUncheckedUpdateWithoutLeadInput>
  }

  export type LeadNoteUpdateManyWithWhereWithoutLeadInput = {
    where: LeadNoteScalarWhereInput
    data: XOR<LeadNoteUpdateManyMutationInput, LeadNoteUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadNoteScalarWhereInput = {
    AND?: LeadNoteScalarWhereInput | LeadNoteScalarWhereInput[]
    OR?: LeadNoteScalarWhereInput[]
    NOT?: LeadNoteScalarWhereInput | LeadNoteScalarWhereInput[]
    id?: StringFilter<"LeadNote"> | string
    content?: StringFilter<"LeadNote"> | string
    type?: StringFilter<"LeadNote"> | string
    createdAt?: DateTimeFilter<"LeadNote"> | Date | string
    leadId?: StringFilter<"LeadNote"> | string
  }

  export type SkipTraceRecordUpsertWithWhereUniqueWithoutLeadInput = {
    where: SkipTraceRecordWhereUniqueInput
    update: XOR<SkipTraceRecordUpdateWithoutLeadInput, SkipTraceRecordUncheckedUpdateWithoutLeadInput>
    create: XOR<SkipTraceRecordCreateWithoutLeadInput, SkipTraceRecordUncheckedCreateWithoutLeadInput>
  }

  export type SkipTraceRecordUpdateWithWhereUniqueWithoutLeadInput = {
    where: SkipTraceRecordWhereUniqueInput
    data: XOR<SkipTraceRecordUpdateWithoutLeadInput, SkipTraceRecordUncheckedUpdateWithoutLeadInput>
  }

  export type SkipTraceRecordUpdateManyWithWhereWithoutLeadInput = {
    where: SkipTraceRecordScalarWhereInput
    data: XOR<SkipTraceRecordUpdateManyMutationInput, SkipTraceRecordUncheckedUpdateManyWithoutLeadInput>
  }

  export type SkipTraceRecordScalarWhereInput = {
    AND?: SkipTraceRecordScalarWhereInput | SkipTraceRecordScalarWhereInput[]
    OR?: SkipTraceRecordScalarWhereInput[]
    NOT?: SkipTraceRecordScalarWhereInput | SkipTraceRecordScalarWhereInput[]
    id?: StringFilter<"SkipTraceRecord"> | string
    provider?: StringFilter<"SkipTraceRecord"> | string
    status?: StringFilter<"SkipTraceRecord"> | string
    requestData?: StringFilter<"SkipTraceRecord"> | string
    responseData?: StringNullableFilter<"SkipTraceRecord"> | string | null
    cost?: FloatNullableFilter<"SkipTraceRecord"> | number | null
    confidence?: FloatNullableFilter<"SkipTraceRecord"> | number | null
    createdAt?: DateTimeFilter<"SkipTraceRecord"> | Date | string
    completedAt?: DateTimeNullableFilter<"SkipTraceRecord"> | Date | string | null
    leadId?: StringFilter<"SkipTraceRecord"> | string
  }

  export type LeadCreateWithoutLeadNotesInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organization: OrganizationCreateNestedOneWithoutLeadsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    callLogs?: CallLogCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutLeadNotesInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organizationId: string
    assignedToId?: string | null
    callLogs?: CallLogUncheckedCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutLeadNotesInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutLeadNotesInput, LeadUncheckedCreateWithoutLeadNotesInput>
  }

  export type LeadUpsertWithoutLeadNotesInput = {
    update: XOR<LeadUpdateWithoutLeadNotesInput, LeadUncheckedUpdateWithoutLeadNotesInput>
    create: XOR<LeadCreateWithoutLeadNotesInput, LeadUncheckedCreateWithoutLeadNotesInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutLeadNotesInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutLeadNotesInput, LeadUncheckedUpdateWithoutLeadNotesInput>
  }

  export type LeadUpdateWithoutLeadNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutLeadsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    callLogs?: CallLogUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutLeadNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    callLogs?: CallLogUncheckedUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateWithoutSkipTraceRecordsInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organization: OrganizationCreateNestedOneWithoutLeadsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    callLogs?: CallLogCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutSkipTraceRecordsInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organizationId: string
    assignedToId?: string | null
    callLogs?: CallLogUncheckedCreateNestedManyWithoutLeadInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutSkipTraceRecordsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutSkipTraceRecordsInput, LeadUncheckedCreateWithoutSkipTraceRecordsInput>
  }

  export type LeadUpsertWithoutSkipTraceRecordsInput = {
    update: XOR<LeadUpdateWithoutSkipTraceRecordsInput, LeadUncheckedUpdateWithoutSkipTraceRecordsInput>
    create: XOR<LeadCreateWithoutSkipTraceRecordsInput, LeadUncheckedCreateWithoutSkipTraceRecordsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutSkipTraceRecordsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutSkipTraceRecordsInput, LeadUncheckedUpdateWithoutSkipTraceRecordsInput>
  }

  export type LeadUpdateWithoutSkipTraceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutLeadsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    callLogs?: CallLogUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutSkipTraceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    callLogs?: CallLogUncheckedUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type OrganizationCreateWithoutCampaignsInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    users?: UserCreateNestedManyWithoutOrganizationInput
    leads?: LeadCreateNestedManyWithoutOrganizationInput
    callLogs?: CallLogCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrganizationInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCampaignsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCampaignsInput, OrganizationUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignLogCreateWithoutCampaignInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    lead: LeadCreateNestedOneWithoutCampaignLogsInput
    user?: UserCreateNestedOneWithoutCampaignLogsInput
  }

  export type CampaignLogUncheckedCreateWithoutCampaignInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    leadId: string
    userId?: string | null
  }

  export type CampaignLogCreateOrConnectWithoutCampaignInput = {
    where: CampaignLogWhereUniqueInput
    create: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLogCreateManyCampaignInputEnvelope = {
    data: CampaignLogCreateManyCampaignInput | CampaignLogCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutCampaignsInput = {
    update: XOR<OrganizationUpdateWithoutCampaignsInput, OrganizationUncheckedUpdateWithoutCampaignsInput>
    create: XOR<OrganizationCreateWithoutCampaignsInput, OrganizationUncheckedCreateWithoutCampaignsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCampaignsInput, OrganizationUncheckedUpdateWithoutCampaignsInput>
  }

  export type OrganizationUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutOrganizationNestedInput
    leads?: LeadUpdateManyWithoutOrganizationNestedInput
    callLogs?: CallLogUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrganizationNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CampaignLogUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLogWhereUniqueInput
    update: XOR<CampaignLogUpdateWithoutCampaignInput, CampaignLogUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLogUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLogWhereUniqueInput
    data: XOR<CampaignLogUpdateWithoutCampaignInput, CampaignLogUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignLogUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignLogScalarWhereInput
    data: XOR<CampaignLogUpdateManyMutationInput, CampaignLogUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignCreateWithoutCampaignLogsInput = {
    id?: string
    name: string
    type: string
    status?: string
    subject?: string | null
    message: string
    script?: string | null
    filters: string
    targetCount?: number
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sent?: number
    delivered?: number
    opened?: number
    clicked?: number
    replied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutCampaignLogsInput = {
    id?: string
    name: string
    type: string
    status?: string
    subject?: string | null
    message: string
    script?: string | null
    filters: string
    targetCount?: number
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sent?: number
    delivered?: number
    opened?: number
    clicked?: number
    replied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type CampaignCreateOrConnectWithoutCampaignLogsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaignLogsInput, CampaignUncheckedCreateWithoutCampaignLogsInput>
  }

  export type LeadCreateWithoutCampaignLogsInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organization: OrganizationCreateNestedOneWithoutLeadsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    callLogs?: CallLogCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutCampaignLogsInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organizationId: string
    assignedToId?: string | null
    callLogs?: CallLogUncheckedCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteUncheckedCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutCampaignLogsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutCampaignLogsInput, LeadUncheckedCreateWithoutCampaignLogsInput>
  }

  export type UserCreateWithoutCampaignLogsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    callLogs?: CallLogCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCampaignLogsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCampaignLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignLogsInput, UserUncheckedCreateWithoutCampaignLogsInput>
  }

  export type CampaignUpsertWithoutCampaignLogsInput = {
    update: XOR<CampaignUpdateWithoutCampaignLogsInput, CampaignUncheckedUpdateWithoutCampaignLogsInput>
    create: XOR<CampaignCreateWithoutCampaignLogsInput, CampaignUncheckedCreateWithoutCampaignLogsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCampaignLogsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCampaignLogsInput, CampaignUncheckedUpdateWithoutCampaignLogsInput>
  }

  export type CampaignUpdateWithoutCampaignLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaignLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadUpsertWithoutCampaignLogsInput = {
    update: XOR<LeadUpdateWithoutCampaignLogsInput, LeadUncheckedUpdateWithoutCampaignLogsInput>
    create: XOR<LeadCreateWithoutCampaignLogsInput, LeadUncheckedCreateWithoutCampaignLogsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutCampaignLogsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutCampaignLogsInput, LeadUncheckedUpdateWithoutCampaignLogsInput>
  }

  export type LeadUpdateWithoutCampaignLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutLeadsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    callLogs?: CallLogUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutCampaignLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    callLogs?: CallLogUncheckedUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUncheckedUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type UserUpsertWithoutCampaignLogsInput = {
    update: XOR<UserUpdateWithoutCampaignLogsInput, UserUncheckedUpdateWithoutCampaignLogsInput>
    create: XOR<UserCreateWithoutCampaignLogsInput, UserUncheckedCreateWithoutCampaignLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignLogsInput, UserUncheckedUpdateWithoutCampaignLogsInput>
  }

  export type UserUpdateWithoutCampaignLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    callLogs?: CallLogUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type LeadCreateWithoutCallLogsInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organization: OrganizationCreateNestedOneWithoutLeadsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutCallLogsInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organizationId: string
    assignedToId?: string | null
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutLeadInput
    leadNotes?: LeadNoteUncheckedCreateNestedManyWithoutLeadInput
    skipTraceRecords?: SkipTraceRecordUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutCallLogsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutCallLogsInput, LeadUncheckedCreateWithoutCallLogsInput>
  }

  export type OrganizationCreateWithoutCallLogsInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    users?: UserCreateNestedManyWithoutOrganizationInput
    leads?: LeadCreateNestedManyWithoutOrganizationInput
    campaigns?: CampaignCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCallLogsInput = {
    id?: string
    name: string
    plan?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monthlyLeadCount?: number
    monthlySkipTraceCount?: number
    monthlyCampaignCount?: number
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    leads?: LeadUncheckedCreateNestedManyWithoutOrganizationInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCallLogsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCallLogsInput, OrganizationUncheckedCreateWithoutCallLogsInput>
  }

  export type UserCreateWithoutCallLogsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    campaignLogs?: CampaignLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCallLogsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    campaignLogs?: CampaignLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCallLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCallLogsInput, UserUncheckedCreateWithoutCallLogsInput>
  }

  export type LeadUpsertWithoutCallLogsInput = {
    update: XOR<LeadUpdateWithoutCallLogsInput, LeadUncheckedUpdateWithoutCallLogsInput>
    create: XOR<LeadCreateWithoutCallLogsInput, LeadUncheckedCreateWithoutCallLogsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutCallLogsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutCallLogsInput, LeadUncheckedUpdateWithoutCallLogsInput>
  }

  export type LeadUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutLeadsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUncheckedUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type OrganizationUpsertWithoutCallLogsInput = {
    update: XOR<OrganizationUpdateWithoutCallLogsInput, OrganizationUncheckedUpdateWithoutCallLogsInput>
    create: XOR<OrganizationCreateWithoutCallLogsInput, OrganizationUncheckedCreateWithoutCallLogsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCallLogsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCallLogsInput, OrganizationUncheckedUpdateWithoutCallLogsInput>
  }

  export type OrganizationUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutOrganizationNestedInput
    leads?: LeadUpdateManyWithoutOrganizationNestedInput
    campaigns?: CampaignUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyLeadCount?: IntFieldUpdateOperationsInput | number
    monthlySkipTraceCount?: IntFieldUpdateOperationsInput | number
    monthlyCampaignCount?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    leads?: LeadUncheckedUpdateManyWithoutOrganizationNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutCallLogsInput = {
    update: XOR<UserUpdateWithoutCallLogsInput, UserUncheckedUpdateWithoutCallLogsInput>
    create: XOR<UserCreateWithoutCallLogsInput, UserUncheckedCreateWithoutCallLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCallLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCallLogsInput, UserUncheckedUpdateWithoutCallLogsInput>
  }

  export type UserUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateManyOrganizationInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    assignedToId?: string | null
  }

  export type CampaignCreateManyOrganizationInput = {
    id?: string
    name: string
    type: string
    status?: string
    subject?: string | null
    message: string
    script?: string | null
    filters: string
    targetCount?: number
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sent?: number
    delivered?: number
    opened?: number
    clicked?: number
    replied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallLogCreateManyOrganizationInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    leadId: string
    createdById: string
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    callLogs?: CallLogUpdateManyWithoutCreatedByNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutCreatedByNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    callLogs?: CallLogUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    callLogs?: CallLogUncheckedUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUncheckedUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignLogs?: CampaignLogUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    filters?: StringFieldUpdateOperationsInput | string
    targetCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    opened?: IntFieldUpdateOperationsInput | number
    clicked?: IntFieldUpdateOperationsInput | number
    replied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallLogUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutCallLogsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCallLogsNestedInput
  }

  export type CallLogUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type CallLogUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCreateManyAssignedToInput = {
    id?: string
    status?: string
    source: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyAddress: string
    city: string
    state: string
    zipCode: string
    propertyType?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    squareFootage?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    normalizedAddress?: string | null
    listPrice?: number | null
    arv?: number | null
    estimatedValue?: number | null
    estimatedRepairs?: number | null
    marketValue?: number | null
    loanAmount?: number | null
    equity?: number | null
    equityPercent?: number | null
    lastSalePrice?: number | null
    lastSaleDate?: Date | string | null
    taxAssessedValue?: number | null
    ownerName?: string | null
    ownerPhone?: string | null
    ownerEmail?: string | null
    ownerAddress?: string | null
    isAbsenteeOwner?: boolean
    phonesJson?: string | null
    emailsJson?: string | null
    skipTraceProvider?: string | null
    skipTraceCostCents?: number | null
    skipTracedAt?: Date | string | null
    dncFlag?: boolean
    motivationScore?: number | null
    motivationFactors?: string | null
    distressSignals?: string | null
    timeOnMarket?: number | null
    priceReductions?: number | null
    aiScore?: number | null
    aiCostCents?: number | null
    aiScoredAt?: Date | string | null
    aiSummary?: string | null
    dealPotential?: string | null
    profitEstimate?: number | null
    temperatureTag?: string | null
    tags: string
    isActive?: boolean
    organizationId: string
  }

  export type CallLogCreateManyCreatedByInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    leadId: string
    organizationId: string
  }

  export type CampaignLogCreateManyUserInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaignId: string
    leadId: string
  }

  export type LeadUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutLeadsNestedInput
    callLogs?: CallLogUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
    callLogs?: CallLogUncheckedUpdateManyWithoutLeadNestedInput
    campaignLogs?: CampaignLogUncheckedUpdateManyWithoutLeadNestedInput
    leadNotes?: LeadNoteUncheckedUpdateManyWithoutLeadNestedInput
    skipTraceRecords?: SkipTraceRecordUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    normalizedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    listPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    arv?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedRepairs?: NullableFloatFieldUpdateOperationsInput | number | null
    marketValue?: NullableFloatFieldUpdateOperationsInput | number | null
    loanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    equity?: NullableIntFieldUpdateOperationsInput | number | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSaleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxAssessedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isAbsenteeOwner?: BoolFieldUpdateOperationsInput | boolean
    phonesJson?: NullableStringFieldUpdateOperationsInput | string | null
    emailsJson?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    skipTraceCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    skipTracedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dncFlag?: BoolFieldUpdateOperationsInput | boolean
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    motivationFactors?: NullableStringFieldUpdateOperationsInput | string | null
    distressSignals?: NullableStringFieldUpdateOperationsInput | string | null
    timeOnMarket?: NullableIntFieldUpdateOperationsInput | number | null
    priceReductions?: NullableIntFieldUpdateOperationsInput | number | null
    aiScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    aiScoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    dealPotential?: NullableStringFieldUpdateOperationsInput | string | null
    profitEstimate?: NullableFloatFieldUpdateOperationsInput | number | null
    temperatureTag?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type CallLogUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutCallLogsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutCallLogsNestedInput
  }

  export type CallLogUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type CallLogUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutCampaignLogsNestedInput
    lead?: LeadUpdateOneRequiredWithoutCampaignLogsNestedInput
  }

  export type CampaignLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type CallLogCreateManyLeadInput = {
    id?: string
    direction: string
    status: string
    duration?: number | null
    transcript?: string | null
    recording?: string | null
    fromNumber: string
    toNumber: string
    twilioCallSid?: string | null
    sentiment?: string | null
    aiSummary?: string | null
    motivationScore?: number | null
    outcome?: string | null
    followUpDate?: Date | string | null
    callStartedAt: Date | string
    callEndedAt?: Date | string | null
    createdAt?: Date | string
    organizationId: string
    createdById: string
  }

  export type CampaignLogCreateManyLeadInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    campaignId: string
    userId?: string | null
  }

  export type LeadNoteCreateManyLeadInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
  }

  export type SkipTraceRecordCreateManyLeadInput = {
    id?: string
    provider: string
    status: string
    requestData: string
    responseData?: string | null
    cost?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CallLogUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutCallLogsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCallLogsNestedInput
  }

  export type CallLogUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type CallLogUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: NullableStringFieldUpdateOperationsInput | string | null
    fromNumber?: StringFieldUpdateOperationsInput | string
    toNumber?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    motivationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callStartedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callEndedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignLogUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutCampaignLogsNestedInput
    user?: UserUpdateOneWithoutCampaignLogsNestedInput
  }

  export type CampaignLogUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignLogUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadNoteUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadNoteUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadNoteUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkipTraceRecordUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: StringFieldUpdateOperationsInput | string
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkipTraceRecordUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: StringFieldUpdateOperationsInput | string
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkipTraceRecordUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: StringFieldUpdateOperationsInput | string
    responseData?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignLogCreateManyCampaignInput = {
    id?: string
    status: string
    response?: string | null
    errorMessage?: string | null
    sentAt?: Date | string
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    repliedAt?: Date | string | null
    leadId: string
    userId?: string | null
  }

  export type CampaignLogUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lead?: LeadUpdateOneRequiredWithoutCampaignLogsNestedInput
    user?: UserUpdateOneWithoutCampaignLogsNestedInput
  }

  export type CampaignLogUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignLogUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leadId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadCountOutputTypeDefaultArgs instead
     */
    export type LeadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadDefaultArgs instead
     */
    export type LeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadNoteDefaultArgs instead
     */
    export type LeadNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkipTraceRecordDefaultArgs instead
     */
    export type SkipTraceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkipTraceRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignLogDefaultArgs instead
     */
    export type CampaignLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CallLogDefaultArgs instead
     */
    export type CallLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CallLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScrapingJobDefaultArgs instead
     */
    export type ScrapingJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScrapingJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyRecordDefaultArgs instead
     */
    export type PropertyRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyMetricDefaultArgs instead
     */
    export type DailyMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScraperJobDefaultArgs instead
     */
    export type ScraperJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScraperJobDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}